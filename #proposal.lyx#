#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{typesetting/latex8}
\usepackage{times}
\usepackage{color}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{amsmath, nicefrac}
\usepackage{amssymb, amsthm}
\usepackage{wrapfig}
\usepackage{algorithm, algorithmic}
\usepackage{setspace}
\usepackage{caption}
\usepackage{float}
\usepackage{afterpage}
\usepackage{typesetting/abstract}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{calc}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{footnote}
\usepackage{threeparttable}
\usepackage{colortbl}
% \usepackage{tweaklist}
\usepackage{fancyhdr}
\usepackage[retainorgcmds]{IEEEtrantools}
\usepackage{floatflt}
\usepackage{xspace}

\usepackage{endnotes}
\usepackage{paralist}
\usepackage{typesetting/shortcuts}
\usepackage{tabulary}
\usepackage{mdwlist}
\usepackage{listings}
\usepackage{balance}
\usepackage{url}
\usepackage{parskip}
\usepackage{textcomp}
\usepackage{subcaption}

\usepackage{epstopdf}
\usepackage{fancyvrb}
% \usepackage[T1]{fontenc}

%-------------------------------------------------------------------------

%double spacing for document

\renewcommand{\textfraction}{0.1}
\renewcommand{\topfraction}{0.95}
\renewcommand{\bottomfraction}{0.95}
\renewcommand\floatpagefraction{0.9}
\setcounter{totalnumber}{50} \setcounter{topnumber}{50} \setcounter{bottomnumber}{50}
\renewcommand{\floatsep}{10pt}
\renewcommand{\intextsep}{10pt}
\setlength{\textfloatsep}{10pt}

\renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt}

\newcommand{\eqnlinespace}{\\[5pt]}
\newcommand{\eqnlinespacelarge}{\\[10pt]}
\newcommand{\captionlinespace}{\\[0.05in]}

\renewcommand{\baselinestretch}{1.6}

%\renewcommand{\textwidth}{5.95in}
\setlength{\textwidth}{6.875in}

\renewcommand{\oddsidemargin}{0.5in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_preamble
\options 11pt
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
em Dissertation Prospectus}
\backslash

\backslash
 
\end_layout

\end_inset

 A Full-Spectrum Dependently typed language for testing with dynamic equality
\end_layout

\begin_layout Author
Mark Lemay
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash
 Department of Computer Science, Boston University 
\backslash

\backslash
 
\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Dependent type systems offer a powerful tool to eliminate bugs from programs.
 Interest in dependent types is often driven by the inherent usability of
 such systems: Dependent types systems can re-use that methodology and syntax
 that functional programmers are familiar with for formal proofs.
 This insight has lead to several Full-Spectrum languages that try and present
 programmers with a consistent and unrestricted view of proofs and programs.
 However these languages still have substantial usability issues: missing
 features like general recursion, confusingly conservative equality, an
 inability to prototype, and no straight forward way to test specifications
 that have not yet been proven.
\end_layout

\begin_layout Abstract
I attempt to solve these problems by building a new language that contains
 standard functional programming features such as general recursion, with
 a gradualized equality, runtime proof search and a testing system.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The promise of dependent types in a practical programming language has been
 the goal of research projects for decades.
 There have been many formalization and prototypes that make different compromis
es in the design space.
 One popular direction to explore is 
\begin_inset Quotes eld
\end_inset

Full-spectrum
\begin_inset Quotes erd
\end_inset

 dependently types languages, these languages tend to have a minimalist
 approach: computation can appear anywhere in a term or type.
 Such a design purposely exposes the Curry-Howard correspondence, as opposed
 to trying to hide it as a technical foundation: a proof has the exact same
 syntax and behavior as a program.
 This direct approach tries to make clear to the programmer the subtleties
 of the proof system that are often obscured by other formal method systems.
 Even though this style makes writing efficient programs hard, and drastically
 complicates the ability to encode effects, it can be seen in some of the
 most popular dependently typed languages (notably Agda and Idris).
\end_layout

\begin_layout Standard
However there are several inconveniences with languages in this style: 
\end_layout

\begin_layout Enumerate
Restrictions on standard programming features, such as general recursion
\end_layout

\begin_layout Enumerate
A subtle and weak notion of type equality
\end_layout

\begin_layout Enumerate
Difficulties in prototyping proofs and programs
\end_layout

\begin_layout Enumerate
Difficulties in testing programs that make use of dependent types
\end_layout

\begin_layout Standard
While each problem will be treated as separately as possible, the nature
 of dependent types requires that equality is modified before testing and
 prototyping can be handled.
 The notion of equality itself is also very sensitive to which programmatic
 features are included.
 My thesis will solve these problems by
\end_layout

\begin_layout Itemize
Defining a full-spectrum dependently typed base language, with a few of
 the most essential programming features like general recursion and user
 defined data types
\end_layout

\begin_layout Itemize
A generalization of that base language that supports dynamic equality checking
 with blame tracking
\end_layout

\begin_layout Itemize
Syntax that supports runtime proof search
\end_layout

\begin_layout Itemize
A symbolic testing system that will exercise terms with uncertain equalities
 and runtime proof search
\end_layout

\begin_layout Section
A Dependently Typed Base Language
\end_layout

\begin_layout Standard
The base language contains the features:
\end_layout

\begin_layout Itemize
Full-Spectrum Dependent types
\end_layout

\begin_layout Itemize
Unrestricted user defined dependent data types (no requirement of strict
 positivity)
\end_layout

\begin_layout Itemize
Unrestricted recursion (no required termination checking)
\end_layout

\begin_layout Itemize
Type-in-type (no predictive hierarchy of universes)
\end_layout

\begin_layout Standard
Any one of these features can result in logical unsoundness
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Every type is inhabited by an infinite loop.
\end_layout

\end_inset

, but they are widely used in mainstream functional programming.
 In spite of the logical unsoundness, the resulting language is still has
 type soundness
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
No term with a reduct that applies an argument to a non-function in the
 empty context will type.
\end_layout

\end_inset

.
 This seems ideal for a programming language since logically sound proofs
 can still be defined and logical unsoundness can be discovered through
 traditional testing.
 Importantly no desirable computation is prevented.
\end_layout

\begin_layout Standard
Though this language is not logically sound it supports a partial correctness
 property for first order data types when run with CBV, for instance:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\mathtt{IsEven}\,x
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 may not terminate, but if it does, 
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 will be an even 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 However, this property does not extend to functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\left(y:\mathbb{N}\right)\rightarrow x\leq y
\]

\end_inset


\end_layout

\begin_layout Standard
it is possible that 
\begin_inset Formula $\mathtt{fst}\,M\equiv7$
\end_inset

 if 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M\equiv\left\langle 7,\lambda y.\mathtt{loopForever}\right\rangle 
\]

\end_inset


\end_layout

\begin_layout Standard
The hope would be that the type is sufficient to communicate intent, in
 the same way unproductive non-termination is typeable in mainstream programming
 languages but still considered a bug.
\end_layout

\begin_layout Standard
Since arbitrary computation can appear in types, the type systems need to
 characterize what computations are equivalent.
 The base language associates all terms that are 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalent, a conventional choice for intensional type theories.
 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence is undecidable for general recursion so type checking for this
 language is undecidable, however this has not been a problem in practice
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While languages like Coq and Agda claim decidable typechecking, it is easy
 to construct terms who's type verification would exceed the computational
 resources of the universe.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The implementation additionally supports top level functions, unrestricted
 mutual recursion for functions and data and is written in a bidirectional
 style allowing some annotations to be inferred.
\end_layout

\begin_layout Subsection
Prior work for the Base Language
\end_layout

\begin_layout Standard
While many of these features have been explored in theory and implemented
 in practice, I am unaware of any development with exactly this formulation.
\end_layout

\begin_layout Standard
Unsound logical systems go back to at least to Church's lambda calculus
 which was originally intended to be a logical foundation.
 Martin Lof proposed a system with Type-in-type that was shown logically
 unsound by Girard.
 The first proof of type soundness for general recursive functions that
 I am aware of came form the Trellys Project 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

, it contains many similar features, but base language uses a simpler notion
 of equality and dependent data resulting in an arguably simpler proof of
 type soundness.
 Further work in the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 used modalities to separate the terminating and non terminating fragments
 of the language, thought the annotations burden seemed too high in practice.
 
\end_layout

\begin_layout Standard
Many implementations support this combination of features without proofs
 of type soundness.
 Cayenne 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/289423.289451"
literal "false"

\end_inset

 was an early Haskell like language combined dependent types with and non-termin
ation.
 Agda supports general recursion and Type-in-type with compiler flags, and
 can simulate some non-positive data types using coinduction.
 Idris supports similar 
\begin_inset Quotes eld
\end_inset

unsafe
\begin_inset Quotes erd
\end_inset

 features.
\end_layout

\begin_layout Standard
The base language has been deeply informed by the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "kimmell2012equational"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015programming"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 and the Zombie Language
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/sweirich/trellys
\end_layout

\end_inset

 it produced.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "jia2010dependent"
literal "false"

\end_inset

 claims a similar 
\begin_inset Quotes eld
\end_inset

partial correctness
\begin_inset Quotes erd
\end_inset

 criterion.
\end_layout

\begin_layout Section
A Language with Dynamic Type Equality
\end_layout

\begin_layout Standard
A key issue with full-spectrum dependent type theories is the characterization
 of definitional equality.
 Since computation can appear at the type level, and types must be checked
 for equality, traditional dependent type theories pick a subset of equivalences
 to support.
 For instance, the base language follows the common choice of 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence of terms.
 However this causes many obvious programs to not type-check:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathtt{Vec} & :\mathbb{N}\rightarrow*\rightarrow*\\
\mathtt{rep} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec}\,x\,\mathbb{B}\\
\mathtt{head} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec}\,\left(1+x\right)\,\mathbb{B}\rightarrow\mathbb{B}\\
\cancel{\vdash} & \lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $1+x$
\end_inset

 does not have the same definition as 
\begin_inset Formula $x+1$
\end_inset

.
\end_layout

\begin_layout Standard
Overly fine definitional equalities directly results in the poor error messages
 that are common for dependently typed languages 
\begin_inset CommandInset citation
LatexCommand cite
key "eremondi2019framework"
literal "false"

\end_inset

.
 For instance, the above will give the error message 
\begin_inset Quotes eld
\end_inset

x + 1 != suc x of type 
\begin_inset Formula $\mathbb{N}$
\end_inset

 when checking that the expression rep (x + 1) has type Vec Bool (1 + x)
\begin_inset Quotes erd
\end_inset

 in Agda.
 The error is confusing since it objects to an intended property of addition,
 and if addition were buggy no hints would be given to fix the problem.
 Ideally the error messages would give a specific instance of 
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x+1\neq1+x$
\end_inset

 or remain silent.
 There is some evidence that specific examples can help clarify the error
 messages in OCaml
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2951913.2951915"
literal "false"

\end_inset

 and there has been an effort to make refinement type error messages more
 concrete in Liquid Haskell
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Strengthening the equality relation in dependently typed languages is used
 to motivate many research projects (to name a few 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx2021taming,sjoberg2015programming"
literal "false"

\end_inset

).
 It is unlikely those impressive efforts are suitable for non exerts, since
 programmers expect the data types and functions they define to have the
 properties the expect to have.
 Asking a programmer to build a custom confluent rewrite system on top of
 their functions is unrealistic
\begin_inset CommandInset citation
LatexCommand cite
key "cockx2021taming"
literal "false"

\end_inset

.
 Asking programmers to translate their datatype into SAT input, likewise
 requires toomuch prerquisite knowledge.
 Even asking programmers to prove the equational properties that can then
 be used automaticvally
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015programming"
literal "false"

\end_inset

 is off putting.
 Needing to know the datails of definitional equality makes choices that
 would be irelivent in Haskell, subtle and complicated.
 
\end_layout

\begin_layout Standard
Additionally , every attempt to extend the definitional equalities of dependent
 type theory I am aware of intends to preserve decidable type checking and/or
 logical soundness, so equality will never be complete
\begin_inset Foot
status open

\begin_layout Plain Layout
I am also unaware of any suitable notion of complete extentional equality
 for depnendent type theory though it is considered in 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 .
\end_layout

\end_inset

.
 Since dependently typed languages with the practical features outlined
 in base language are already incompatible with logical soundness and decidable
 type checking, perhaps equality can also be made more convenient.
\end_layout

\begin_layout Standard
Building off the base language I purpose a dynamic cast language, and a
 cast type system.
 Programs that do not type in the base language can be elaborated into the
 cast langage.
 The cast language has a weakened notion of type soundness such that 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $e'\downarrow v'$
\end_inset

 and 
\begin_inset Formula $\vdash_{c}v':M'$
\end_inset

 
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $e'\uparrow$
\end_inset

 
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $e'\downarrow blame$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
Type soundness is preserved, or inequality can be proven at a specific source
 location.
 In the example above 
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 will not emit any errors at compile time or runtime (though a warning may
 be given).
 
\end_layout

\begin_layout Standard
If the example is changed to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,x\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\]

\end_inset


\end_layout

\begin_layout Standard
at runtime the blame tracking system will blame the exact static location
 that uses unequal types with a direct proof of inequality, allowing an
 error like 
\begin_inset Quotes eld
\end_inset

failed at application 
\begin_inset Formula $\left(\mathtt{head}\,x:\mathtt{Vec}\,\underline{\left(1+x\right)}\,\mathbb{B}\rightarrow...\right)\left(rep\,x:\mathtt{Vec}\,\underline{x}\,\mathbb{B}\right)$
\end_inset

 since when 
\begin_inset Formula $x=3$
\end_inset

, 
\begin_inset Formula $1+x=4\neq3=x$
\end_inset


\begin_inset Quotes erd
\end_inset

, regardless of where in the program the discrepency was discovered.
\end_layout

\begin_layout Standard
Just as standard type thoerys allow many possible characterizations of equality
 that support logical soundness, there are many choices of runtime permisiveness.
 The minimal choice that supports type soundness is liky too permisive in
 practice.
 Alternatively, I conjecture that checking that matches the partial correctness
 critretia above would be reaonably intuitive.
\end_layout

\begin_layout Standard
Taking insperation from the 
\begin_inset Quotes eld
\end_inset

gradual guarentee
\begin_inset Quotes erd
\end_inset

 of gradual typing, there are several basic properties in addition to type
 soundness that this cast language hopes to fufil:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash e:M$
\end_inset

, 
\begin_inset Formula $elab\left(M,*\right)=M'$
\end_inset

, and 
\begin_inset Formula $elab\left(e,M'\right)=e'$
\end_inset

 then 
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

 and 
\begin_inset Formula $e'\downarrow blame$
\end_inset

 then there is no 
\begin_inset Formula $\vdash e:M$
\end_inset

 such that 
\begin_inset Formula $elab\left(M,*\right)=M'$
\end_inset

, 
\begin_inset Formula $elab\left(e,M'\right)=e'$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':*$
\end_inset

 and 
\begin_inset Formula $elab\left(e,*\right)=e'$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow*$
\end_inset

 then 
\begin_inset Formula $e\downarrow*$
\end_inset


\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow(x:M')\rightarrow N'$
\end_inset

 then 
\begin_inset Formula $e\downarrow(x:M)\rightarrow N$
\end_inset

 
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow TCon\triangle'$
\end_inset

 then 
\begin_inset Formula $e\downarrow TCon\triangle$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
The first condition states that every typed term in the base language can
 be embedded in the cast language.
 The second condition shows that errors are not sperous.
 The third condition shows that except for error, observations are consistent
 (with large eliminations, term constructors can also be observed).
\end_layout

\begin_layout Subsection
Prior work
\end_layout

\begin_layout Standard
It is unsurprising that dynamic quality is shares many of the same concerns
 as the large amount of work for contracts, hybrid types, gradual types,
 and blame.
 In fact, this work could be seen as gradualizing the Reflection Rule in
 Extensional Type Theory.
\end_layout

\begin_layout Standard
Blame has been strongly advocated for in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-00590-9_1,wadler:LIPIcs:2015:5033"
literal "false"

\end_inset

.
 Blame tracking can establish the reasonableness of monitoring systems systems
 by linking a dynamic failure directly to the broken static invariant.
 As many authors have noticed, proving blame correctness is tedious and
 error prone, it is often only conjectured.
\end_layout

\begin_layout Standard
The basic correctness conditions are inspired by the Gradual Guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031"
literal "false"

\end_inset

.
 The implementation also takes inspiration from 
\begin_inset Quotes eld
\end_inset

Abstracting gradual typing
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2837614.2837670"
literal "false"

\end_inset

, where static evidence annotations become runtime checks.
 Unlike some impressive attempts to gradualize the polymorphic lambda calculus
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3110283"
literal "false"

\end_inset

, dynamic equality does not attempt to preserve any parametric properties
 of the base language.
 It is unclear how useful such a restriction would be in practice.
\end_layout

\begin_layout Standard
A direct attempt has been made to gradualize a full spectrum dependently
 typed language to an untyped lambda calculus using the AGT philosophy in
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3341692"
literal "false"

\end_inset

.
 However that system retains the definitional style of equality and user
 defined data types are not supported.
 The paper is largely concerned with establishing decidable type checking
 via an approximate term normalization.
\end_layout

\begin_layout Standard
A refinement type system with higher order features is gradualized in 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 though it does not appear powerful enough to be characterized a a full-spectrum
 dependent type theory.
 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 builds on earlier refinement type system work, which described itself as
 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

 .
 A notable example is 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/1-4020-8141-3_34"
literal "false"

\end_inset

 which describes a refinement system that limit's predicates to base types.
\end_layout

\begin_layout Section
Prototyping proofs and programs
\end_layout

\begin_layout Standard
Just as 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equalities are missing from the definitional relation, 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 proofs and programs are not always conveniently available to the programmer.
 For instance, in Agda it is possible to write a sorting sorting function
 quickly using simple types.
 With effort is it possible to prove that sorting procedure correct by rewriting
 it with the necessarily invariants.
 However very little is offered in between.
 The problem is magnified if module boundaries hide the implementation details
 of a function, since the details are exactly what is needed to make a proof!
 This is especially important for larger scale software where a library
 may expect proof terms that while 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 are not constructible from the exports of the other library.
\end_layout

\begin_layout Standard
The solution proposed here is some additional syntax that will search for
 a term of the type when resolved at runtime.
 Given the sorting function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{sort}:\mathtt{List}\,\mathbb{N}\rightarrow\mathtt{List}\,\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
and given the first order predicate that 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{IsSorted}:\mathtt{List}\,\mathbb{N}\rightarrow*
\]

\end_inset


\end_layout

\begin_layout Standard
then it is possible to assert that 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 behaves as expected with
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.?:\left(x:\mathtt{List}\,\mathbb{N}\right)\rightarrow\mathtt{IsSorted}\left(\mathtt{sort}x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
this term will act like any other term at runtime, given a list input it
 will verify that the 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 function correctly handles that input, give an error, or non-terminate.
\end_layout

\begin_layout Standard
Additionally this would allow simple prototyping form first order specification.
 For instance,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
data\,\mathtt{Mult} & :\mathbb{N}\rightarrow\mathbb{N}\rightarrow\mathbb{N}\rightarrow*\,where\\
\mathtt{base} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Mult}0\,x\,0\\
\mathtt{suc} & :\left(x\,y\,z:\mathbb{N}\right)\rightarrow\mathtt{Mult}\,x\,y\,z\rightarrow\mathtt{Mult}\,\left(1+x\right)\,y\,(y+z)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
can be used to prototype
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{div}=\lambda x.\lambda y.\mathtt{fst}\left(?:\sum z:\mathbb{N}.\mathtt{Mult}x\,y\,z\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The term search can be suproisingly subtle, for instance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
?:\sum f:\mathbb{N}\rightarrow\mathbb{N}.\mathtt{Id}\left(f,\lambda x.x+1\right)\&\mathtt{Id}\left(f,\lambda x.1+x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
depends on the definitional properties of functions.
 To avoid this subtlty I plan to only support term search over first order
 data.
\end_layout

\begin_layout Standard
Though the proof search is currently primitive, better search methods could
 be incorporated in future work.
\end_layout

\begin_layout Subsection
Prior work
\end_layout

\begin_layout Standard
Proof search is often used for static term generation in dependently typed
 languages (for instance Coq tactics).
 A first order theorem prover is attached to Agda in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Twelf made use of runtime proof search but the underling theory cannot be
 considered full spectrum.
\end_layout

\begin_layout Section
Testing dependent programs
\end_layout

\begin_layout Standard
Both dynamic equalities and dynamic proof search vastly weaken the guarantees
 of normal dependent type systems.
 Programmers still would like a evidence of correctness, even while they
 intend to provide full proofs of properties in the future.
 However, there are few options available in full spectrum dependently typed
 languages aside from costly and sometimes unconstructable proofs.
\end_layout

\begin_layout Standard
The mainstream software industry has similar needs for evidence of correctness,
 and has made use of testing done in a separate execution phase.
 Given the rich specifications that dependent types provide it is possible
 to improve on the hand crafted tests used by most of the industry.
 Instead we can use a type directed symbolic execution, to run questionable
 equalities over concrete values and engage and precompute the searched
 proof terms.
 Precomputed proof terms can be cached, so that exploration is not too inefficie
nt in the common case of repeating tests at regular intervals of code that
 is mostly the same.
 Precomputed terms can be made available at runtime, covering for the inefficien
t search procedure.
 
\end_layout

\begin_layout Standard
Intrestingly dynamic equality is necisary for testing like this, since otherwise
, definitional properties of functions would need to be acounted for.
 Using dynamic equality it is possible only consider the extensional behavior
 of functions.
\end_layout

\begin_layout Standard
Finally future work can add more advanced methods of testing and proof generatio
n.
 This architecture should make it easier to add more advanced exploration
 and search without changing the underlining definitional behavior.
\end_layout

\begin_layout Subsection
Prior work 
\end_layout

\begin_layout Subsubsection
Symbolic Execution
\end_layout

\begin_layout Standard
Most research for Symbolic Execution targets popular languages (like C)
 and uses SMT solvers to efficiently explore conditional branches that depend
 on base types.
 Most work does not support higher order functions or makes simplifying
 assumptions about the type system.
 There are however some relevant papers:
\end_layout

\begin_layout Itemize
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

 presents a symbolic execution engine supporting Haskell's lazy execution
 and type system.
 Higher order functions are not handled
\end_layout

\begin_layout Itemize
The draft work
\begin_inset CommandInset citation
LatexCommand cite
key "2006.11639"
literal "false"

\end_inset

, handles higher order functions as and inputs provides a proof of completeness
\end_layout

\begin_layout Itemize
Symbolic execution for higher order functions for a limited untyped variant
 of PCF is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "nguyen2017higher"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Testing dependent types
\end_layout

\begin_layout Standard
There has been a long recognized need for testing in addition to proving
 in dependent type systems
\end_layout

\begin_layout Itemize
In 
\begin_inset CommandInset citation
LatexCommand cite
key "dybjer2003combining"
literal "false"

\end_inset

 a QuickCheck style framework was added to an earlier version of Agda
\end_layout

\begin_layout Itemize
QuickChick
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/QuickChick/QuickChick
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "denes2014quickchick"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lampropoulos2017generating,lampropoulos2017beginner,lampropoulos2018random"
literal "false"

\end_inset

 is a research project to add testing to Coq.
 However testing requires building types classes that establish the properties
 needed by the testing framework such as decidable equality.
 This is presumably out of reach of novice Coq users.
\end_layout

\begin_layout Section
Reservations
\end_layout

\begin_layout Subsection
Purity
\end_layout

\begin_layout Standard
The base language is pure in the Haskell sense
\begin_inset Foot
status open

\begin_layout Plain Layout
the only effects are non termination and unhandled exceptions.
\end_layout

\end_inset

, an thus has many of the usability issues of languages in that style.
 Handling effects in a principled convienient way in mainstream functionl
 programing languages is an ongoing reasurch effort.
 Notable areas of reasurch include Algebraic Effects and Handlers, and Linear
 Type systems.
\end_layout

\begin_layout Standard
Effects have been combined with dependent types in a limited fassion with
 Hoare Type Theory (HTT)
\begin_inset CommandInset citation
LatexCommand cite
key "nanevski2005dependent"
literal "false"

\end_inset

 and ATS.
\end_layout

\begin_layout Standard
Combing effects with Full-Spectrum dependent types is substaially more difficult
 becuase effectful equality is hard to characterize for indevidual efects
 or effects in combination.
 Several attempts have been made, 
\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ahman2017handling,ahman2017fibred"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 but there is still a lot of work to be done.
\end_layout

\begin_layout Subsection
Implicit arguments
\end_layout

\begin_layout Standard
The base language currently has no mechinism for marking arguments implicit.
 Implicit arguments drastically improve the usability of dependent type
 systems, often taking the place of type infernece in ML style languages.
 They have been left out of the base language so that alternatives can be
 explored.
\end_layout

\begin_layout Subsection
Dependent data
\end_layout

\begin_layout Standard
The current presentation of data in the base language is powerfull but there
 are inconvinces:
\end_layout

\begin_layout Itemize
The base languege is based on eliminators with an explicit motive.
 Nested pattern matching is not supported which is suprisingly subtle 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

 with dependent types.
\end_layout

\begin_layout Itemize
Data types in the base language support dependent indicies, but not 
\begin_inset Quotes eld
\end_inset

Parameters
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
There is no reduction in expressiveness, but these features should be added
 to make the language more convineint.
\end_layout

\begin_layout Section
Status
\end_layout

\begin_layout Itemize
I have a prototype of the cast langugae supporting all features.
 However the casting of data types will need to be reworked.
 I believe I can prove all the properties on the sublanugage without data.
 I expect it is possible to prove the properties on the language with data
 as well, though I need to work through those details.
\end_layout

\begin_layout Itemize
Substatinal work was completed on the proofsearch for the extended abstract,
 though it will need to be revisited.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "C:/icfp/dtest/extended-abstract/dtest"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
