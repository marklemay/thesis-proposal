#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{typesetting/latex8}
\usepackage{times}
\usepackage{color}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{amsmath, nicefrac}
\usepackage{amssymb, amsthm}
\usepackage{wrapfig}
\usepackage{algorithm, algorithmic}
\usepackage{setspace}
\usepackage{caption}
\usepackage{float}
\usepackage{afterpage}
\usepackage{typesetting/abstract}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{calc}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{footnote}
\usepackage{threeparttable}
\usepackage{colortbl}
% \usepackage{tweaklist}
\usepackage{fancyhdr}
\usepackage[retainorgcmds]{IEEEtrantools}
\usepackage{floatflt}
\usepackage{xspace}

\usepackage{endnotes}
\usepackage{paralist}
\usepackage{typesetting/shortcuts}
\usepackage{tabulary}
\usepackage{mdwlist}
\usepackage{listings}
\usepackage{balance}
\usepackage{url}
\usepackage{parskip}
\usepackage{textcomp}
\usepackage{subcaption}

\usepackage{epstopdf}
\usepackage{fancyvrb}
% \usepackage[T1]{fontenc}

%-------------------------------------------------------------------------

%double spacing for document

\renewcommand{\textfraction}{0.1}
\renewcommand{\topfraction}{0.95}
\renewcommand{\bottomfraction}{0.95}
\renewcommand\floatpagefraction{0.9}
\setcounter{totalnumber}{50} \setcounter{topnumber}{50} \setcounter{bottomnumber}{50}
\renewcommand{\floatsep}{10pt}
\renewcommand{\intextsep}{10pt}
\setlength{\textfloatsep}{10pt}

\renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt}

\newcommand{\eqnlinespace}{\\[5pt]}
\newcommand{\eqnlinespacelarge}{\\[10pt]}
\newcommand{\captionlinespace}{\\[0.05in]}

\renewcommand{\baselinestretch}{1.6}

%\renewcommand{\textwidth}{5.95in}
\setlength{\textwidth}{6.875in}

\renewcommand{\oddsidemargin}{0.5in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_preamble
\options 11pt
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
em Dissertation Prospectus}
\backslash

\backslash
 
\end_layout

\end_inset

 A Full-Spectrum Dependently Typed Language for Programming with Dynamic
 Equality, Testing, and Runtime Proof Search
\end_layout

\begin_layout Author
Mark Lemay
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash
 Department of Computer Science, Boston University 
\backslash

\backslash
 
\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Dependent type systems are a powerful tool to eliminate bugs from programs.
 Unlike other systems of formal methods, dependent types systems can re-use
 the syntax and methodology that functional programmers are already familiar
 with, for the construction of formal proofs.
 This insight has lead to several full-spectrum languages that try to present
 programmers with a consistent view of proofs and programs.
 However, these languages still have substantial usability issues: missing
 features like general recursion, confusingly conservative equality, and
 no straightforward way to test and use properties that have not yet been
 proven.
\end_layout

\begin_layout Abstract
These issues are not superficial, but are tied to some of the conventional
 assumptions of dependent type theory.
 Logical soundness is essential when dependent type systems are used as
 a mathematical foundation, but may be too restrictive in a programming
 language.
 Conservative equality is easy to hand-wave away informally, but it makes
 many reasonable programs not type check.
 Users often experience these language properties as inexplicable static
 errors, and cannot debug their programs using conventional dynamic techniques.
 In practice, exploratory programming can be difficult in these systems.
\end_layout

\begin_layout Abstract
My solution to these problems is a dependently typed 
\begin_inset Quotes eld
\end_inset

surface
\begin_inset Quotes erd
\end_inset

 language with programmatic features that supports type sound, but logically
 unsound execution.
 This language can then be generalized into a dynamic 
\begin_inset Quotes eld
\end_inset

cast
\begin_inset Quotes erd
\end_inset

 language provisionally accepting many more equalities.
 Programmers trade poor static errors for precise counterexamples that are
 made available at runtime.
 Additionally, automated testing provides a way to transition properties
 form intent to proof.
 Finally, a runtime proof search feature allows programmers to take advantage
 of this machinery for runtime prototyping.
\end_layout

\begin_layout Abstract
Currently, the surface language is implemented and the cast language is
 being cleaned up.
 Several properties have been prove for these languages.
 Earlier prototypes of for automated testing and runtime proof search will
 need to be rewritten to accommodate changes changes to the cast language.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The Curry-Howard correspondence identifies functions with theorems, providing
 a mutually beneficial link between well explored areas of math and software
 engineering.
 This connection is most pronounced in dependent typed systems that provide
 a common language to write programs about proofs and proofs about programs.
 Specifically, dependent type systems allow types to depend on terms, supporting
 an extremely powerful system of specification, computation and proof evidence.
 
\end_layout

\begin_layout Standard
For instance, in a dependently typed language it is possible to prove the
 correctness of a sorting function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
sort\,:\,\left(input:List\,\mathbb{N}\right)\rightarrow\Sigma ls:List\,\mathbb{N}.IsSorted\,input\,ls
\]

\end_inset


\end_layout

\begin_layout Standard
by providing an appropriate term of that type.
 Unlike other systems of formal methods, the additional logical power does
 not require the programmer understand any additional syntax or semantics.
 From the programmer's perspective the function arrow and the implication
 arrow are the same.
 The proof 
\begin_inset Formula $IsSorted$
\end_inset

 is no different then any other term of a datatype like 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $List$
\end_inset

 or 
\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\end_layout

\begin_layout Standard
The promise of dependent types in a practical programming language has inspired
 research projects for decades.
 There have been many formalization and prototypes that make different compromis
es in the design space.
 One of the most popular styles is 
\begin_inset Quotes eld
\end_inset

full-spectrum
\begin_inset Quotes erd
\end_inset

 dependent types, these languages tend to have a minimalist approach: computatio
n can appear anywhere in a term or type.
 Such a design purposely exposes the Curry-Howard correspondence, as opposed
 to merely using it as a convenient logical foundation: a proof has the
 exact same syntax and behavior as a program.
 Even though this style makes writing efficient programs hard, and drastically
 complicates the ability to use effects, it can be seen in some of the most
 popular dependently typed programming languages such as Agda and Idris.
\end_layout

\begin_layout Standard
Despite the potential, users often find these systems difficult to use.
 The common symptom of these issues can be seen in the confusing error messages
 these languages produce.
 For instance in Agda this reasonable looking program 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathtt{Vec} & :*\rightarrow\mathbb{N}\rightarrow*\\
\mathtt{rep} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec\,\mathbb{B}}\,x\\
\mathtt{head} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec}\,\mathbb{B}\,\left(1+x\right)\rightarrow\mathbb{B}\\
\cancel{\vdash} & \lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
will give the error 
\begin_inset Quotes eld
\end_inset

x + 1 != suc x of type 
\begin_inset Formula $\mathbb{N}$
\end_inset

 when checking that the expression rep (x + 1) has type Vec 
\begin_inset Formula $\mathbb{B}$
\end_inset

 (1 + x)
\begin_inset Quotes erd
\end_inset

.
 The error is confusing since it objects to an intended property of addition,
 and if addition were buggy no hints are given to fix the problem.
 While an expert in type theory can appreciate the subtleties of definitional
 equality, programmers would prefer an error message that gives a specific
 instance of 
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x+1\neq1+x$
\end_inset

 or be allowed to run their program.
 
\end_layout

\begin_layout Standard
Strengthening the equality relation in dependently typed languages has been
 the goal for many research projects (to name a few 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx2021taming,sjoberg2015programming"
literal "false"

\end_inset

).
 However, it is unlikely those impressive efforts are suitable for non-exerts,
 since programmers expect the data types and functions they define to have
 the properties they were intended to have.
 None of these projects makes the underling equality less complicated.
 No system will be able to verify every 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equality for arbitrary user defined data types and functions statically,
 since program equivalence is famously undecidable.
\end_layout

\begin_layout Standard
Alternatively we could assume the equalities hold and discover a concrete
 inequality as a runtime error.
 There is some evidence that specific examples like this can help clarify
 the error messages in OCaml
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2951913.2951915"
literal "false"

\end_inset

 and there has been an effort to make refinement type error messages more
 concrete and other systems like Liquid Haskell
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

.
 This leads to a different workflow then traditional type systems, instead
 of type checking first and only then executing the program, execution and
 type checking can both inform the programmer.
\end_layout

\begin_layout Standard
Several steps have been taken to make this new workflow possible.
 Section 2 will describe a conventional dependently typed base language
 with some programmatic features.
 Section 3 describes a dynamic extension to that language that supports
 dependent equality and the conditions that would make an implementation
 reasonable.
 Section 4 covers some of the other features a language in this style could
 support.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% progress has been separated into several independent results
\end_layout

\end_inset


\end_layout

\begin_layout Section
A Dependently Typed Surface Language
\end_layout

\begin_layout Standard
The dynamic dependent equality of the later sections is hard to study without
 a more conventional dependently typed language to serve as a reference.
 This surface language contains the key features that should be supported:
 user defined dependent functions and dependent datatypes.
 The surface language uses a 
\begin_inset Quotes eld
\end_inset

full-spectrum
\begin_inset Quotes erd
\end_inset

 style.
 The dynamic language from the next section can be elaborated from and compared
 to this concrete implementation.
\end_layout

\begin_layout Standard
The language is pure in the sense of Haskell, supporting only non-termination
 and unchecked errors as effects.
 Combining other effects with full-spectrum dependent types is substantially
 more difficult because effectful equality is hard to characterize for individua
l effects and especially hard for effects in combination.
 Several attempts have been made to combine dependent types with more effects,
 
\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ahman2017handling,ahman2017fibred"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 but there is still a lot of work to be done.
 Effects, though undoubtedly useful, are not considered in the base language.
\end_layout

\begin_layout Standard
Since this work emphasizes programming over theorem proving, the language
 contains these logically dubious features:
\end_layout

\begin_layout Itemize
Unrestricted recursion (no required termination checking)
\end_layout

\begin_layout Itemize
Unrestricted user defined dependent data types (no requirement of strict
 positivity)
\end_layout

\begin_layout Itemize
Type-in-Type (no hierarchy of universes)
\end_layout

\begin_layout Standard
Any one of these features can result in logical unsoundness
\begin_inset Foot
status open

\begin_layout Plain Layout
Every type is inhabited by an infinite loop.
\end_layout

\end_inset

, but they seem helpful for mainstream functional programming.
 In spite of logical unsoundness, the resulting language still has type
 soundness
\begin_inset Foot
status open

\begin_layout Plain Layout
No term typed in an empty context will 
\begin_inset Quotes eld
\end_inset

get stuck
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
 Additionally non-termination causes type-checking to be undecidable, though
 this has not caused any issues in practice, and even decidable type-checking
 in dependent type theory is computationally intractable.
\end_layout

\begin_layout Standard
Logical soundness seems not to matter in programming practice.
 For instance, in ML the type 
\begin_inset Formula $\mathtt{f:Int->Int}$
\end_inset

 does not imply the termination of 
\begin_inset Formula $\mathtt{f\,2}$
\end_inset

.
 While unproductive non-termination is always a bug, it seems an easy bug
 to detect and fix when it occurs.
 In mainstream languages, types help to communicate the intent of termination,
 even though termination is not guaranteed by the type system.
 Therefore, logical unsoundness seems suitable for a dependently typed programmi
ng language since proofs can still be encoded and logical unsoundness can
 be discovered through traditional testing, or warned about in a non-blocking
 way.
 Importantly, no desirable computation is prevented in order to preserve
 logical soundness.
 
\end_layout

\begin_layout Standard
The surface language still supports a partial correctness property for first
 order data types when run with Call-by-Value.
 For instance:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\mathtt{IsEven}\,x
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 may not terminate, but if it does, 
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 will be an even 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 However, this property does not extend to functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\left(y:\mathbb{N}\right)\rightarrow x\leq y
\]

\end_inset


\end_layout

\begin_layout Standard
it is possible that 
\begin_inset Formula $\mathtt{fst}\,M\equiv7$
\end_inset

 if 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M\equiv\left\langle 7,\lambda y.\mathtt{loopForever}\right\rangle 
\]

\end_inset


\end_layout

\begin_layout Standard
The surface language has been fully implemented.
 I have proven type soundness for the full surface language (follows a similar
 structure to 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

), Qiancheng Fu has mechanized my proof of type soundness for the function
 fragment in Coq.
 Details are in a paper currently under submission at TyDe workshop.
\end_layout

\begin_layout Subsection
Prior work
\end_layout

\begin_layout Standard
While many of these features have been explored in theory and implemented
 in practice, I am unaware of any development with exactly this formulation.
\end_layout

\begin_layout Standard
Unsound logical systems that are acceptable programming languages go back
 to at least Church's lambda calculus which was originally intended to be
 a logical foundation for mathematics.
 In the 1970s, Martin Lof proposed a system with Type-in-Type that was shown
 logically unsound by Girard (as described in the introduction in 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin-Lof-1972"
literal "false"

\end_inset

).
 In the 1980s, Cardelli explored the domain semantics of a system with general
 recursive dependent functions and Type-in-Type
\begin_inset CommandInset citation
LatexCommand cite
key "cardelli1986polymorphic"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The first proof of type soundness for a language with general recursive
 dependent functions, Type-in-Type, and dependent data that I am aware of
 came form the Trellys Project 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

.
 At the time their language had several additional features, not included
 in my surface language.
 Additionally the surface language uses a simpler notion of equality and
 dependent data resulting in an arguably simpler proof of type soundness.
 Later work in the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 used modalities to separate the terminating and non terminating fragments
 of the language, though the annotation burden seems high in retrospect.
 In general, the base language has been deeply informed by the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "kimmell2012equational"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015programming"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 and the Zombie Language
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/sweirich/trellys
\end_layout

\end_inset

 it produced.
\end_layout

\begin_layout Standard
Several implementations support this combination of features without proofs
 of type soundness.
 Cayenne 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/289423.289451"
literal "false"

\end_inset

 is a Haskell like language that combined dependent types with Type-in-type,
 data and non-termination.
 Agda supports general recursion and Type-in-Type with compiler flags, and
 can simulate some non-positive data types using coinduction.
 Idris supports similar 
\begin_inset Quotes eld
\end_inset

unsafe
\begin_inset Quotes erd
\end_inset

 features.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "jia2010dependent"
literal "false"

\end_inset

 introduces a similar 
\begin_inset Quotes eld
\end_inset

partial correctness
\begin_inset Quotes erd
\end_inset

 criterion for dependent languages with non-termination run with Call-by-Value.
\end_layout

\begin_layout Section
A Language with Dynamic Type Equality
\end_layout

\begin_layout Standard
A key issue with dependent type theories is the characterization of definitional
 equality.
 Since computation can appear at the type level, and types must be checked
 for equality, dependent type theories must define what computational equalities
 they intend to equate for type checking.
 For instance, the base language follows the common choice of 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence of terms.
 However, this causes many programs to not type-check.
 For instance 
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 will not type-check since 
\begin_inset Formula $1+x$
\end_inset

 does not have the same normalized syntax as 
\begin_inset Formula $x+1$
\end_inset

.
\end_layout

\begin_layout Standard
This is a widely recognized issue with dependent type theories.
 However, most attempts to improve the equality relation intend to preserve
 decidable type checking and/or logical soundness, so equality will never
 be complete
\begin_inset Foot
status open

\begin_layout Plain Layout
I am unaware of any suitable notion of complete extensional equality for
 dependent type theory though it is considered briefly in 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 .
\end_layout

\end_inset

.
 Since dependently typed languages with the practical features outlined
 in surface language are already incompatible with logical soundness and
 decidable type checking, these concerns no longer apply.
\end_layout

\begin_layout Standard
The surface language can be extended to a cast language that supports the
 expectation of the original typing.
 Many programs that do not type in the base language can be elaborated into
 the cast language.
 The cast language has a weaker notion of type soundness, called cast soundness,
 such that 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash a:A$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $a$
\end_inset

 is a value
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $a\rightsquigarrow a'$
\end_inset

 where 
\begin_inset Formula $\vdash a':A$
\end_inset


\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $a$
\end_inset

can blame a source location with a specific witness of inequality
\end_layout

\end_deeper
\begin_layout Standard
In short, type soundness holds, or a a good error message can be given.
 In the example above 
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 will not cause any type checking errors or runtime errors (though a static
 warning may be given).
 
\end_layout

\begin_layout Standard
If the example is changed to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,x\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\]

\end_inset


\end_layout

\begin_layout Standard
and the function is called at runtime, the blame tracking system will blame
 the exact static location that uses unequal types with a direct proof of
 inequality, allowing an error like 
\begin_inset Quotes eld
\end_inset

failed at application 
\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\mathtt{head}\,x:\mathtt{Vec}\,\underline{\left(1+x\right)}\,\mathbb{B}\rightarrow...\right)\left(rep\,x:\mathtt{Vec}\,\underline{x}\,\mathbb{B}\right)$
\end_inset

 since when 
\begin_inset Formula $x=3$
\end_inset

, 
\begin_inset Formula $1+x=4\neq3=x$
\end_inset


\begin_inset Quotes erd
\end_inset

, regardless of when the function was called in the program and where the
 discrepancy was discovered.
\end_layout

\begin_layout Standard
Cast soundness improves on the naive solution of ignoring type annotations
 for execution, since without type soundness, the returned error may appear
 unrelated to the problematic type assumption (
\begin_inset Quotes eld
\end_inset

3 applied to 7 but 7 is not a function
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard
Just as standard type theories allow many possible characterizations of
 equality that support logical soundness, there are many choices of runtime
 checking that support this weaker notion of type soundness.
 The minimal choice is likely too permissive in practice: in the example
 above, it would only flag an error when the function is applied to 0.
 Alternatively, I conjecture that runtime-checking that matches the partial
 correctness criteria above would be reasonably intuitive.
 Extending checks into non-dependent function types also seems reasonable,
 and would allow simple types to be completely checked.
\end_layout

\begin_layout Standard
Taking inspiration from the 
\begin_inset Quotes eld
\end_inset

gradual guarantee
\begin_inset Quotes erd
\end_inset

 of gradual typing
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031"
literal "false"

\end_inset

, there are several basic properties that should hold when terms of the
 surface language elaborate into terms of the cast language.
\end_layout

\begin_layout Enumerate
The elaboration procedure only produces well cast terms
\end_layout

\begin_layout Enumerate
Every term typed in the surface language elaborates
\end_layout

\begin_layout Enumerate
Errors are not spurious, errors never point to anything that type-checked
 in the surface language
\end_layout

\begin_layout Enumerate
Whenever an elaborated cast term evaluates, the corresponding surface term
 evaluates consistently
\end_layout

\begin_layout Standard
A prototype implementation for the cast language and elaboration procedure
 have been completed.
 All properties have been proven for the functional fragment.
 Qiancheng Fu has mechanized my proof of cast soundness in Coq.
\end_layout

\begin_layout Subsection
Prior work
\end_layout

\begin_layout Standard
It is unsurprising that dynamic equality shares many of the same concerns
 as the large amount of work for contracts, hybrid types, gradual types,
 and blame.
 In fact, this work could be seen as gradualizing the Reflection Rule in
 Extensional Type Theory.
\begin_inset ERT
status open

\begin_layout Plain Layout

% cite ETT?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Blame has been strongly advocated for in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-00590-9_1,wadler:LIPIcs:2015:5033"
literal "false"

\end_inset

.
 Blame tracking can help establish the reasonableness of monitoring systems
 by linking a dynamic failure directly to the broken invariant in source.
 Blame is also a key ingredient of clear runtime error messages.
 However, as many authors have noticed, proving blame correctness is tedious
 and error prone, it is often only conjectured.
\end_layout

\begin_layout Standard
The basic correctness conditions are inspired by the Gradual Guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031"
literal "false"

\end_inset

.
 The implementation also takes inspiration from 
\begin_inset Quotes eld
\end_inset

Abstracting gradual typing
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2837614.2837670"
literal "false"

\end_inset

, where static evidence annotations become runtime checks.
 Unlike some impressive attempts to gradualize the polymorphic lambda calculus
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3110283"
literal "false"

\end_inset

, dynamic equality does not attempt to preserve any parametric properties
 of the base language.
 It is unclear if such a restriction to parametric properties would be desirable
 for a dependently typed language.
\end_layout

\begin_layout Standard
A direct attempt has been made to gradualize a full-spectrum dependently
 typed language to an untyped lambda calculus using the AGT philosophy in
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3341692"
literal "false"

\end_inset

.
 However that system retains the intentional style of equality and user
 defined data types are not supported.
 The paper is largely concerned with establishing decidable type checking
 via an approximate term normalization.
\end_layout

\begin_layout Standard
A refinement type system with higher order features is gradualized in 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 though it does not appear powerful enough to be characterized as a full-spectru
m dependent type theory.
 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 builds on earlier refinement type system work, which described itself as
 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

.
 A notable example is 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/1-4020-8141-3_34"
literal "false"

\end_inset

 which describes a refinement system that limits predicates to base types.
\end_layout

\begin_layout Section
Further Features
\end_layout

\begin_layout Standard
Dynamic equality appears to be a prerequisite for other useful features.
\end_layout

\begin_layout Subsection
Prototyping proofs and programs
\end_layout

\begin_layout Standard
Just as 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equalities are missing from the definitional relation, 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 proofs and programs are not always conveniently available to the programmer.
 For instance, in Agda it is possible to write a sorting function quickly
 using simple types.
 With effort is it possible to prove that sorting procedure correct by rewriting
 it with the necessarily dependently typed invariants.
 However, very little is offered in between.
 The problem is magnified if module boundaries hide the implementation details
 of a function, since those details are exactly what is needed to make a
 proof! This is especially important for larger scale software where a library
 may require proof terms that while 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 are not constructable from the exports of other libraries.
\end_layout

\begin_layout Standard
The solution proposed here is additional syntax that will search for a term
 of the type when resolved at runtime.
 Given the sorting function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{sort}:\mathtt{List}\,\mathbb{N}\rightarrow\mathtt{List}\,\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
and given the first order predicate that 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{IsSorted}:\mathtt{List}\,\mathbb{N}\rightarrow*
\]

\end_inset


\end_layout

\begin_layout Standard
then it is possible to assert that 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 behaves as expected with
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.?:\left(x:\mathtt{List}\,\mathbb{N}\right)\rightarrow\mathtt{IsSorted}\left(\mathtt{sort}x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
This term will act like any other function at runtime, given a list input
 the function will verify that the 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 correctly handled that input, gives an error, or non-terminate.
\end_layout

\begin_layout Standard
Additionally, this would allow simple prototyping form first order specification.
 For instance,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
data\,\mathtt{Mult} & :\mathbb{N}\rightarrow\mathbb{N}\rightarrow\mathbb{N}\rightarrow*\,where\\
\mathtt{base} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Mult}0\,x\,0\\
\mathtt{suc} & :\left(x\,y\,z:\mathbb{N}\right)\rightarrow\mathtt{Mult}\,x\,y\,z\rightarrow\mathtt{Mult}\,\left(1+x\right)\,y\,(y+z)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
can be used to prototype
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{div}=\lambda z.\lambda x.\mathtt{fst}\left(?:\sum y:\mathbb{N}.\mathtt{Mult}x\,y\,z\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The term search can be surprisingly subtle.
 For instance,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
?:\sum f:\mathbb{N}\rightarrow\mathbb{N}.\mathtt{Id}\left(f,\lambda x.x+1\right)\&\mathtt{Id}\left(f,\lambda x.1+x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
depends on the definitional properties of functions.
 To avoid this subtly I plan to only support term search over first order
 data.
\end_layout

\begin_layout Standard
A primitive proof search was implemented in an earlier prototype, but better
 search methods are planned.
\end_layout

\begin_layout Subsubsection
Prior work
\end_layout

\begin_layout Standard
Proof search is often used for static term generation in dependently typed
 languages (for instance Coq tactics).
 A first order theorem prover is attached to Agda in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Twelf made use of runtime proof search but the underling theory cannot be
 considered full-spectrum.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% mention prolog?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testing dependent programs
\end_layout

\begin_layout Standard
Both dynamic equalities and dynamic proof search vastly weaken the guarantees
 of normal dependent type systems.
 Programmers still would like evidence of correctness, even while they intend
 to provide full proofs in the future.
 However, there are few options available in full-spectrum dependently typed
 languages aside from costly and sometimes unconstructable proofs.
\end_layout

\begin_layout Standard
The mainstream software industry has a similar need for evidence of correctness,
 and has standardized on testing done in a separate execution phase.
 Given the rich specifications that dependent types provide it is possible
 to improve on the hand crafted tests used by most of the industry.
 Instead we can use a type directed symbolic execution, to run questionable
 equalities over concrete values and precompute the searches of proof terms.
 Precomputed proof terms can be cached, so that exploration is not too inefficie
nt in the common case of repeating tests at regular intervals of code that
 is mostly the same.
 Precomputed terms can be made available at runtime, excusing the inefficient
 search procedure.
 
\end_layout

\begin_layout Standard
Interestingly dynamic equality is necessary for testing like this, since
 otherwise, definitional properties of functions would need to be accounted
 for.
 Previous attempts to test dependent specifications were overwhelmed by
 definitional considerations.
 Using dynamic equality it is possible only consider the extensional behavior
 of functions.
\end_layout

\begin_layout Standard
Finally, future work can add more advanced methods of testing and proof
 generation.
 This architecture should make it easier to change exploration and search
 procedures without changing the underlining definitional behavior.
\end_layout

\begin_layout Subsubsection
Prior work 
\end_layout

\begin_layout Subsubsection
Symbolic Execution
\end_layout

\begin_layout Standard
Most research for Symbolic Execution targets popular imperative languages
 (like C) and uses SMT solvers to efficiently explore conditional branches
 that depend on base types.
 Most work does not support higher order functions or makes simplifying
 assumptions about the type system.
 There are however some relevant papers:
\end_layout

\begin_layout Itemize
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

 presents a symbolic execution engine supporting Haskell's lazy execution
 and type system.
 Higher order functions are not handled
\end_layout

\begin_layout Itemize
The draft work
\begin_inset CommandInset citation
LatexCommand cite
key "2006.11639"
literal "false"

\end_inset

, handles higher order functions as inputs and provides a proof of completeness
\end_layout

\begin_layout Itemize
Symbolic execution for higher order functions for a limited untyped variant
 of PCF is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "nguyen2017higher"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Testing dependent types
\end_layout

\begin_layout Standard
There has been a long recognized need for testing in addition to proving
 in dependent type systems
\end_layout

\begin_layout Itemize
In 
\begin_inset CommandInset citation
LatexCommand cite
key "dybjer2003combining"
literal "false"

\end_inset

 a QuickCheck style framework was added to an earlier version of Agda
\end_layout

\begin_layout Itemize
QuickChick
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/QuickChick/QuickChick
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "denes2014quickchick"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lampropoulos2017generating,lampropoulos2017beginner,lampropoulos2018random"
literal "false"

\end_inset

 is a research project to add testing to Coq.
 However, testing requires building types classes that establish the properties
 needed by the testing framework such as decidable equality.
 This is presumably out of reach of novice Coq users.
\end_layout

\begin_layout Section
Status and Plan
\end_layout

\begin_layout Subsection
Status
\end_layout

\begin_layout Standard
I am rewriting a prototype for dynamic equality to support for all the features
 of the base language.
 The fragment for dependent function types and type universes satisfies
 all the conditions above.
 I believe that all conditions can be made to hold with data types as well.
\end_layout

\begin_layout Standard
The proof search prototype written for the extended abstract presented last
 summer, will need to be corrected to account for dynamic equality.
\end_layout

\begin_layout Subsection
Plan
\end_layout

\begin_layout Itemize
June
\end_layout

\begin_deeper
\begin_layout Itemize
refine implementation
\end_layout

\begin_layout Itemize
write chapters: on the surface language, and on the cast language
\end_layout

\end_deeper
\begin_layout Itemize
July
\end_layout

\begin_deeper
\begin_layout Itemize
finalize the implementation of symbolic execution
\end_layout

\begin_layout Itemize
rework symbolic execution
\begin_inset CommandInset citation
LatexCommand cite
key "extendedabstract"
literal "false"

\end_inset

 to use dynamic equality
\end_layout

\begin_layout Itemize
write chapter: testing and symbolic execution
\end_layout

\end_deeper
\begin_layout Itemize
August
\end_layout

\begin_deeper
\begin_layout Itemize
finalize the implementation of runtime proof search
\end_layout

\begin_layout Itemize
rework symbolic execution
\begin_inset CommandInset citation
LatexCommand cite
key "extendedabstract"
literal "false"

\end_inset

 to use dynamic equality
\end_layout

\begin_layout Itemize
write chapter: runtime proof-search
\end_layout

\end_deeper
\begin_layout Itemize
September
\end_layout

\begin_deeper
\begin_layout Itemize
Write a medium sized example in the language
\end_layout

\begin_layout Itemize
Write the chapter walking thought that example
\end_layout

\end_deeper
\begin_layout Itemize
October
\end_layout

\begin_deeper
\begin_layout Itemize
Finalize: Introduction, Future work, Conclusion
\end_layout

\end_deeper
\begin_layout Itemize
November: Defend
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/dtest/extended-abstract/dtest"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
