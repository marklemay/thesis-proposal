#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Problem Statement Scratch
\end_layout

\begin_layout Standard
The Curry-Howard correspondence identifies functions with theorems, providing
 a promising link between well explored areas of math and software engineering.
 This connection is most pronounced in dependent typed systems that provide
 a common language to write (total functional) programs about proofs and
 (intuitionistic) proofs about programs.
 Specifically, dependent type systems allow types to depend on terms, supporting
 an extremely powerful system of specification, computation and proof evidence.
 
\end_layout

\begin_layout Standard
Many languages have been written or modified to take advantage of dependent
 types, exploring potential trade offs in the design space.
 The most conservative use of dependent types can be seen in languages like
 Liquid Haskell, and Scala 3: function specifications may depend on values
 of some specific types such as int or bool, and users are never expected
 to write there own proofs.
 More advanced languages like Ats and F* allow function specifications to
 depend on a wider range of types, have built in automated support to solve
 some proofs automatically, and allow users to supply their own proof when
 automation fails.
 Full-spectrum dependent type languages like Agda, Idris, Zombie and the
 underlining language of Coq place almost no restriction on what terms may
 appear in types, and use the same syntactic construct to represent functions,
 type polymorphism, logical implication, and universal quantification.
 There is some evidence that Full-spectrum languages with uniform syntax
 like Agda and Idris are easier to learn
\begin_inset Foot
status open

\begin_layout Plain Layout
TODO: PFLA
\end_layout

\end_inset

, even if expert users can prove more in Coq, ATS can produce far more efficeint
 code, and Haskell / Scala are compatible with massive well maintained software
 ecosystems.
\end_layout

\begin_layout Standard
However, dependent type systems, especially full-spectrum dependent type
 systems, can be cumbersome when used as programming languages.
 If functions are exactly theorems then termination must be proven for every
 function to guarantee logical soundness.
 If the user takes full advantage of the dependent types, they will be obligated
 to prove many tedious facts about their user defined types and functions.
 The logic in which to prove these facts is conservative: the law of the
 excluded middle is unavailable since it cannot be given a pure computational
 interpretation.
 A user may be prevented from running their program until the lemmas are
 proven or unsafely postulated.
 For this reason, is commonly recommended that programmers limit their use
 of dependent types and postulate all 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 properties to be proven last.
 There will be no warning that a postulate is incorrect unless complicated
 3rd party tools are used.
\end_layout

\begin_layout Standard
Most issues of dependent types systems can be translated into the inability
 to summon a convenient term at type checking time.
 On one hand this is reasonable: such a term may not exists, require unsupported
 reasoning like the law of the excluded middle, or take too long to construct.
 On the other hand, all of these arguments may be equally made against postulate
s, even though they are a critical tool to develop dependently typed programs.
 Interestingly, if proof functions were to be evaluated, the postulate could
 always be replaced with a value of it's type if the postulate is correct.
 If a postulate is incorrect, a clear error can often be presented.
 In the case of postulated equality, a term will always be easy to synthesize
 or refute at runtime.
\end_layout

\begin_layout Standard
I propose interpreting postulates as impure proof search that may be carried
 out at runtime.
 Since proof terms are rarely evaluated directly, I also propose an apparently
 novel symbolic execution of dependently typed programs that reveal issues
 with postulated facts without delaying type checking.
 Additionally, proof search can be precompute offline allowing postulates
 to be used in a pragmatically relevant way.
 
\end_layout

\begin_layout Standard
...Vitually all programs are full of bug.
 Many solutions have been proposed to to find or prevent bugs in programs.
 Industry thoughly tests software with automated testing programs.
 The programming language community has proposed dependentent type systems
 to prove functions meet their specifications.
 Tests are easy to use but incomplete.
 Dependentent type systems are poweful but hard to learn and use.
 This thesis attempts to merge the convinence of testing and the surtianty
 of proof into a new langauge that is geard twords being correct, but is
 more flexible then traditional dependently typed languages while keeping
 the language as simple as possible from the user perspective.To achieve
 this, I have built a pure, full spectrum base language that supports common
 programming features suche as data types and general recursion.
 I gradualize the equality relation of base language to that is the source
 of many of the usabilities of depentent type theory.
 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
However these languages are still difficult to use.
 Why are the error messages so bad? 
\end_layout

\begin_layout Standard
I attempt to solve what I see as the most pressinf forms of 
\end_layout

\begin_layout Standard
Vitually all programs are full of bug.
 One of the most promising techniques is for fighting bug is advanced Type
 systems such those Dependent types are great.
 But hard to use.
 Solve with a dependent lang that leans program like
\end_layout

\begin_layout Standard
Dependent Types.
 can proove
\end_layout

\begin_layout Part*
TODO
\end_layout

\begin_layout Standard
Should the troughline be partial correctness?
\end_layout

\begin_layout Standard
stronger condition 
\begin_inset Formula $\vdash e:M$
\end_inset

 and 
\begin_inset Formula $elab\left(e,M\right)=e'$
\end_inset

 and 
\begin_inset Formula $elab\left(M,*\right)=M'$
\end_inset

 then 
\begin_inset Formula $\vdash e':M'$
\end_inset

 
\end_layout

\begin_layout Standard
It would still be possible to add additional static checks to warn, of nontermin
ation, negative data, and dangourous predicativity.
 However this is also true for mainstream functional languages and has never
 been considered a priority.
\end_layout

\begin_layout Standard
pure
\end_layout

\begin_layout Standard
Why are people intrested in this part of the design space
\end_layout

\begin_layout Standard
Target mundane mistakes, mundane properties can still have costly proofs
\end_layout

\begin_layout Standard
..
\end_layout

\begin_layout Standard
long understood problem with dependently typed languages in this style:
 equality.
 Since types need to know when they are equal, and computation can occur
 in types there must be some account of what computations are equal.
 
\end_layout

\begin_layout Standard
.
 For this reason, the languages does not need parrellel syntax as in stratified
 systems such as ATS.
\end_layout

\begin_layout Standard
equalities are missing from .Another problem frequently encounted in dependent
 type systems is that proof and program constructions must be constructed
 or imported manually to be used correctly.
\end_layout

\begin_layout Standard
e dificulty of exploritory programming.
 Perogams and proofs are well supported in their final form but only some
 support is given 
\end_layout

\begin_layout Standard
proof The solution is testing, idealy symbolic typedirected testing.
 
\end_layout

\begin_layout Part*
TODO
\end_layout

\begin_layout Standard
This direct approach tries to make clear to the programmer the subtleties
 of the proof system that are often obscured by other formal method systems.
 
\end_layout

\begin_layout Standard
Error messages like this reflect foundations of how dependently typed languages
 handle equality.
\end_layout

\begin_layout Standard
...Dependent Equality
\end_layout

\begin_layout Standard
In a dependent type system computation can appear in types, so the type
 system needs to characterize what computations are equivalent.
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
There are many possibilities 
\end_layout

\begin_layout Standard
The base language associates all terms that are 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalent, a conventional choice for intensional type theories.
 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence is undecidable for general recursion so type checking for this
 language is undecidable, however this has not been a problem in practice
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While languages like Coq and Agda claim decidable typechecking, it is easy
 to construct terms who's type verification would exceed the computational
 resources of the universe.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The implementation additionally supports top level functions, unrestricted
 mutual recursion for functions and data and is written in a bidirectional
 style allowing some annotations to be inferred.
\end_layout

\begin_layout Standard
Equalty is a core issue of Dependent Type Theory.
 Many approaches have been proposed in general, 
\end_layout

\begin_layout Part*
TODO
\end_layout

\begin_layout Standard
However there are several inconveniences with languages in this style, that
 often result in confusion from users
\end_layout

\begin_layout Enumerate
Restrictions on standard programming features, such as general recursion
\end_layout

\begin_layout Enumerate
A subtle and weak notion of type equality
\end_layout

\begin_layout Enumerate
Difficulties in prototyping proofs and programs
\end_layout

\begin_layout Enumerate
Difficulties in testing programs that make use of dependent types
\end_layout

\begin_layout Standard
While each problem will be treated as separately as possible, the nature
 of dependent types requires that equality is modified before testing and
 prototyping can be handled.
 The notion of equality itself is also very sensitive to which programmatic
 features are included.
 My thesis will solve these problems by
\end_layout

\begin_layout Itemize
Defining a full-spectrum dependently typed base language, with a few of
 the most essential programming features like general recursion and user
 defined data types
\end_layout

\begin_layout Itemize
A generalization of that base language that supports dynamic equality checking
 with blame tracking
\end_layout

\begin_layout Itemize
Syntax that supports runtime proof search
\end_layout

\begin_layout Itemize
A symbolic testing system that will exercise terms with uncertain equalities
 and runtime proof search
\end_layout

\begin_layout Section
A Dependently Typed Base Language
\end_layout

\begin_layout Standard
The base language contains the features:
\end_layout

\begin_layout Itemize
Full-Spectrum Dependent types
\end_layout

\begin_layout Itemize
Unrestricted user defined dependent data types (no requirement of strict
 positivity)
\end_layout

\begin_layout Itemize
Unrestricted recursion (no required termination checking)
\end_layout

\begin_layout Itemize
Type-in-type (no predictive hierarchy of universes)
\end_layout

\begin_layout Standard
Any one of these features can result in logical unsoundness
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Every type is inhabited by an infinite loop.
\end_layout

\end_inset

, but they are widely used in mainstream functional programming.
 In spite of the logical unsoundness, the resulting language is still has
 type soundness
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
No term with a reduct that applies an argument to a non-function in the
 empty context will type.
\end_layout

\end_inset

.
 This seems ideal for a programming language since logically sound proofs
 can still be defined and logical unsoundness can be discovered through
 traditional testing.
 Importantly no desirable computation is prevented.
\end_layout

\begin_layout Standard
Though this language is not logically sound it supports a partial correctness
 property for first order data types when run with CBV, for instance:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\mathtt{IsEven}\,x
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 may not terminate, but if it does, 
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 will be an even 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 However, this property does not extend to functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\left(y:\mathbb{N}\right)\rightarrow x\leq y
\]

\end_inset


\end_layout

\begin_layout Standard
it is possible that 
\begin_inset Formula $\mathtt{fst}\,M\equiv7$
\end_inset

 if 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M\equiv\left\langle 7,\lambda y.\mathtt{loopForever}\right\rangle 
\]

\end_inset


\end_layout

\begin_layout Standard
The hope would be that the type is sufficient to communicate intent, in
 the same way unproductive non-termination is typeable in mainstream programming
 languages but still considered a bug.
\end_layout

\begin_layout Standard
Since arbitrary computation can appear in types, the type systems need to
 characterize what computations are equivalent.
 The base language associates all terms that are 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalent, a conventional choice for intensional type theories.
 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence is undecidable for general recursion so type checking for this
 language is undecidable, however this has not been a problem in practice
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While languages like Coq and Agda claim decidable typechecking, it is easy
 to construct terms who's type verification would exceed the computational
 resources of the universe.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The implementation additionally supports top level functions, unrestricted
 mutual recursion for functions and data and is written in a bidirectional
 style allowing some annotations to be inferred.
\end_layout

\begin_layout Subsection
Prior work for the Base Language
\end_layout

\begin_layout Standard
While many of these features have been explored in theory and implemented
 in practice, I am unaware of any development with exactly this formulation.
\end_layout

\begin_layout Standard
Unsound logical systems go back to at least to Church's lambda calculus
 which was originally intended to be a logical foundation.
 Martin Lof proposed a system with Type-in-type that was shown logically
 unsound by Girard.
 The first proof of type soundness for general recursive functions that
 I am aware of came form the Trellys Project 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

, it contains many similar features, but base language uses a simpler notion
 of equality and dependent data resulting in an arguably simpler proof of
 type soundness.
 Further work in the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 used modalities to separate the terminating and non terminating fragments
 of the language, thought the annotations burden seemed too high in practice.
 
\end_layout

\begin_layout Standard
Many implementations support this combination of features without proofs
 of type soundness.
 Cayenne 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/289423.289451"
literal "false"

\end_inset

 was an early Haskell like language combined dependent types with and non-termin
ation.
 Agda supports general recursion and Type-in-type with compiler flags, and
 can simulate some non-positive data types using coinduction.
 Idris supports similar 
\begin_inset Quotes eld
\end_inset

unsafe
\begin_inset Quotes erd
\end_inset

 features.
\end_layout

\begin_layout Standard
The base language has been deeply informed by the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "kimmell2012equational"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015programming"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 and the Zombie Language
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/sweirich/trellys
\end_layout

\end_inset

 it produced.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "jia2010dependent"
literal "false"

\end_inset

 claims a similar 
\begin_inset Quotes eld
\end_inset

partial correctness
\begin_inset Quotes erd
\end_inset

 criterion.
\end_layout

\begin_layout Section
A Language with Dynamic Type Equality
\end_layout

\begin_layout Standard
A key issue with full-spectrum dependent type theories is the characterization
 of definitional equality.
 Since computation can appear at the type level, and types must be checked
 for equality, traditional dependent type theories pick a subset of equivalences
 to support.
 For instance, the base language follows the common choice of 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence of terms.
 However this causes many obvious programs to not type-check:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathtt{Vec} & :\mathbb{N}\rightarrow*\rightarrow*\\
\mathtt{rep} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec}\,x\,\mathbb{B}\\
\mathtt{head} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec}\,\left(1+x\right)\,\mathbb{B}\rightarrow\mathbb{B}\\
\cancel{\vdash} & \lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $1+x$
\end_inset

 does not have the same definition as 
\begin_inset Formula $x+1$
\end_inset

.
\end_layout

\begin_layout Standard
Overly fine definitional equalities directly results in the poor error messages
 that are common for dependently typed languages 
\begin_inset CommandInset citation
LatexCommand cite
key "eremondi2019framework"
literal "false"

\end_inset

.
 For instance, the above will give the error message 
\begin_inset Quotes eld
\end_inset

x + 1 != suc x of type 
\begin_inset Formula $\mathbb{N}$
\end_inset

 when checking that the expression rep (x + 1) has type Vec Bool (1 + x)
\begin_inset Quotes erd
\end_inset

 in Agda.
 The error is confusing since it objects to an intended property of addition,
 and if addition were buggy no hints would be given to fix the problem.
 Ideally the error messages would give a specific instance of 
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x+1\neq1+x$
\end_inset

 or remain silent.
 There is some evidence that specific examples can help clarify the error
 messages in OCaml
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2951913.2951915"
literal "false"

\end_inset

 and there has been an effort to make refinement type error messages more
 concrete in Liquid Haskell
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Strengthening the equality relation in dependently typed languages is used
 to motivate many research projects (to name a few 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx2021taming,sjoberg2015programming"
literal "false"

\end_inset

).
 It is unlikely those impressive efforts are suitable for non exerts, since
 programmers expect the data types and functions they define to have the
 properties the expect to have.
 Asking a programmer to build a custom confluent rewrite system on top of
 their functions is unrealistic
\begin_inset CommandInset citation
LatexCommand cite
key "cockx2021taming"
literal "false"

\end_inset

.
 Asking programmers to translate their datatype into SAT input, likewise
 requires too much perquisite knowledge.
 Even asking programmers to prove the equational properties that can then
 be used automatically
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015programming"
literal "false"

\end_inset

 is off putting.
 Needing to know the details of definitional equality makes choices that
 would be irreverent in Haskell, subtle and complicated.
 
\end_layout

\begin_layout Standard
Additionally, every attempt to extend the definitional equalities of dependent
 type theory I am aware of intends to preserve decidable type checking and/or
 logical soundness, so equality will never be complete
\begin_inset Foot
status open

\begin_layout Plain Layout
I am also unaware of any suitable notion of complete extensional equality
 for dependent type theory though it is considered in 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 .
\end_layout

\end_inset

.
 Since dependently typed languages with the practical features outlined
 in base language are already incompatible with logical soundness and decidable
 type checking, perhaps equality can also be made more convenient.
\end_layout

\begin_layout Standard
Building off the base language I purpose a dynamic cast language, and a
 cast type system.
 Many programs that do not type in the base language can be elaborated into
 the cast language.
 The cast language has a weaker notion of type soundness such that 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $e'\downarrow v'$
\end_inset

 and 
\begin_inset Formula $\vdash_{c}v':M'$
\end_inset

 
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $e'\uparrow$
\end_inset

 
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $e'\downarrow blame$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
Type soundness is preserved, or inequality can be proven at a specific source
 location.
 In the example above 
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 will not emit any errors at compile time or runtime (though a static warning
 may be given).
 
\end_layout

\begin_layout Standard
If the example is changed to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,x\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\]

\end_inset


\end_layout

\begin_layout Standard
at runtime the blame tracking system will blame the exact static location
 that uses unequal types with a direct proof of inequality, allowing an
 error like 
\begin_inset Quotes eld
\end_inset

failed at application 
\begin_inset Formula $\left(\mathtt{head}\,x:\mathtt{Vec}\,\underline{\left(1+x\right)}\,\mathbb{B}\rightarrow...\right)\left(rep\,x:\mathtt{Vec}\,\underline{x}\,\mathbb{B}\right)$
\end_inset

 since when 
\begin_inset Formula $x=3$
\end_inset

, 
\begin_inset Formula $1+x=4\neq3=x$
\end_inset


\begin_inset Quotes erd
\end_inset

, regardless of where in the program the discrepancy was discovered.
\end_layout

\begin_layout Standard
Just as standard type theories allow many possible characterizations of
 equality that support logical soundness, there are many choices of runtime
 checking.
 The minimal choice that supports type soundness is likely too permissive
 in practice.
 Alternatively, I conjecture that checking that matches the partial correctness
 criteria above would be reasonably intuitive
\begin_inset Foot
status open

\begin_layout Plain Layout
Extending checks into non dependent function types also seems reasonable,
 and would allow simple static type checking
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Taking inspiration from the 
\begin_inset Quotes eld
\end_inset

gradual guarantee
\begin_inset Quotes erd
\end_inset

 of gradual typing, there are several basic properties in addition to type
 soundness that this cast language hopes to fulfill:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash e:M$
\end_inset

, 
\begin_inset Formula $elab\left(M,*\right)=M'$
\end_inset

, and 
\begin_inset Formula $elab\left(e,M'\right)=e'$
\end_inset

 then 
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

 and 
\begin_inset Formula $e'\downarrow blame$
\end_inset

 then there is no 
\begin_inset Formula $\vdash e:M$
\end_inset

 such that 
\begin_inset Formula $elab\left(M,*\right)=M'$
\end_inset

, 
\begin_inset Formula $elab\left(e,M'\right)=e'$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':*$
\end_inset

 and 
\begin_inset Formula $elab\left(e,*\right)=e'$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow*$
\end_inset

 then 
\begin_inset Formula $e\downarrow*$
\end_inset


\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow(x:M')\rightarrow N'$
\end_inset

 then 
\begin_inset Formula $e\downarrow(x:M)\rightarrow N$
\end_inset

 
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow TCon\triangle'$
\end_inset

 then 
\begin_inset Formula $e\downarrow TCon\triangle$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
The first condition states that every typed term in the base language can
 be embedded in the cast language.
 The second condition shows that errors are not spurious.
 The third condition shows that except for error, observations are consistent
 (with large eliminations, term constructors can also be observed).
\end_layout

\begin_layout Subsection
Prior work
\end_layout

\begin_layout Standard
It is unsurprising that dynamic equality is shares many of the same concerns
 as the large amount of work for contracts, hybrid types, gradual types,
 and blame.
 In fact, this work could be seen as gradualizing the Reflection Rule in
 Extensional Type Theory.
\end_layout

\begin_layout Standard
Blame has been strongly advocated for in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-00590-9_1,wadler:LIPIcs:2015:5033"
literal "false"

\end_inset

.
 Blame tracking can establish the reasonableness of monitoring systems systems
 by linking a dynamic failure directly to the broken static invariant.
 As many authors have noticed, proving blame correctness is tedious and
 error prone, it is often only conjectured.
\end_layout

\begin_layout Standard
The basic correctness conditions are inspired by the Gradual Guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031"
literal "false"

\end_inset

.
 The implementation also takes inspiration from 
\begin_inset Quotes eld
\end_inset

Abstracting gradual typing
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2837614.2837670"
literal "false"

\end_inset

, where static evidence annotations become runtime checks.
 Unlike some impressive attempts to gradualize the polymorphic lambda calculus
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3110283"
literal "false"

\end_inset

, dynamic equality does not attempt to preserve any parametric properties
 of the base language.
 It is unclear how useful such a restriction would be in practice.
\end_layout

\begin_layout Standard
A direct attempt has been made to gradualize a full spectrum dependently
 typed language to an untyped lambda calculus using the AGT philosophy in
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3341692"
literal "false"

\end_inset

.
 However that system retains the definitional style of equality and user
 defined data types are not supported.
 The paper is largely concerned with establishing decidable type checking
 via an approximate term normalization.
\end_layout

\begin_layout Standard
A refinement type system with higher order features is gradualized in 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 though it does not appear powerful enough to be characterized a a full-spectrum
 dependent type theory.
 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 builds on earlier refinement type system work, which described itself as
 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

.
 A notable example is 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/1-4020-8141-3_34"
literal "false"

\end_inset

 which describes a refinement system that limit's predicates to base types.
\end_layout

\begin_layout Section
Prototyping proofs and programs
\end_layout

\begin_layout Standard
Just as 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equalities are missing from the definitional relation, 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 proofs and programs are not always conveniently available to the programmer.
 For instance, in Agda it is possible to write a sorting sorting function
 quickly using simple types.
 With effort is it possible to prove that sorting procedure correct by rewriting
 it with the necessarily invariants.
 However very little is offered in between.
 The problem is magnified if module boundaries hide the implementation details
 of a function, since the details are exactly what is needed to make a proof!
 This is especially important for larger scale software where a library
 may require proof terms that while 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 are not constructable from the exports of other libraries.
\end_layout

\begin_layout Standard
The solution proposed here is some additional syntax that will search for
 a term of the type when resolved at runtime.
 Given the sorting function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{sort}:\mathtt{List}\,\mathbb{N}\rightarrow\mathtt{List}\,\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
and given the first order predicate that 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{IsSorted}:\mathtt{List}\,\mathbb{N}\rightarrow*
\]

\end_inset


\end_layout

\begin_layout Standard
then it is possible to assert that 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 behaves as expected with
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.?:\left(x:\mathtt{List}\,\mathbb{N}\right)\rightarrow\mathtt{IsSorted}\left(\mathtt{sort}x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
this term will act like any other term at runtime, given a list input it
 will verify that the 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 function correctly handles that input, give an error, or non-terminate.
\end_layout

\begin_layout Standard
Additionally this would allow simple prototyping form first order specification.
 For instance,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
data\,\mathtt{Mult} & :\mathbb{N}\rightarrow\mathbb{N}\rightarrow\mathbb{N}\rightarrow*\,where\\
\mathtt{base} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Mult}0\,x\,0\\
\mathtt{suc} & :\left(x\,y\,z:\mathbb{N}\right)\rightarrow\mathtt{Mult}\,x\,y\,z\rightarrow\mathtt{Mult}\,\left(1+x\right)\,y\,(y+z)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
can be used to prototype
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{div}=\lambda x.\lambda y.\mathtt{fst}\left(?:\sum z:\mathbb{N}.\mathtt{Mult}x\,y\,z\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The term search can be surprisingly subtle, for instance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
?:\sum f:\mathbb{N}\rightarrow\mathbb{N}.\mathtt{Id}\left(f,\lambda x.x+1\right)\&\mathtt{Id}\left(f,\lambda x.1+x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
depends on the definitional properties of functions.
 To avoid this subtly I plan to only support term search over first order
 data.
\end_layout

\begin_layout Standard
Though the proof search is currently primitive, better search methods could
 be incorporated in future work.
\end_layout

\begin_layout Subsection
Prior work
\end_layout

\begin_layout Standard
Proof search is often used for static term generation in dependently typed
 languages (for instance Coq tactics).
 A first order theorem prover is attached to Agda in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Twelf made use of runtime proof search but the underling theory cannot be
 considered full spectrum.
\end_layout

\begin_layout Section
Testing dependent programs
\end_layout

\begin_layout Standard
Both dynamic equalities and dynamic proof search vastly weaken the guarantees
 of normal dependent type systems.
 Programmers still would like a evidence of correctness, even while they
 intend to provide full proofs of properties in the future.
 However, there are few options available in full spectrum dependently typed
 languages aside from costly and sometimes unconstructable proofs.
\end_layout

\begin_layout Standard
The mainstream software industry has similar needs for evidence of correctness,
 and has made use of testing done in a separate execution phase.
 Given the rich specifications that dependent types provide it is possible
 to improve on the hand crafted tests used by most of the industry.
 Instead we can use a type directed symbolic execution, to run questionable
 equalities over concrete values and engage and precompute the searched
 proof terms.
 Precomputed proof terms can be cached, so that exploration is not too inefficie
nt in the common case of repeating tests at regular intervals of code that
 is mostly the same.
 Precomputed terms can be made available at runtime, covering for the inefficien
t search procedure.
 
\end_layout

\begin_layout Standard
Interestingly dynamic equality is necessary for testing like this, since
 otherwise, definitional properties of functions would need to be accounted
 for.
 Using dynamic equality it is possible only consider the extensional behavior
 of functions.
\end_layout

\begin_layout Standard
Finally future work can add more advanced methods of testing and proof generatio
n.
 This architecture should make it easier to add more advanced exploration
 and search without changing the underlining definitional behavior.
\end_layout

\begin_layout Subsection
Prior work 
\end_layout

\begin_layout Subsubsection
Symbolic Execution
\end_layout

\begin_layout Standard
Most research for Symbolic Execution targets popular languages (like C)
 and uses SMT solvers to efficiently explore conditional branches that depend
 on base types.
 Most work does not support higher order functions or makes simplifying
 assumptions about the type system.
 There are however some relevant papers:
\end_layout

\begin_layout Itemize
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

 presents a symbolic execution engine supporting Haskell's lazy execution
 and type system.
 Higher order functions are not handled
\end_layout

\begin_layout Itemize
The draft work
\begin_inset CommandInset citation
LatexCommand cite
key "2006.11639"
literal "false"

\end_inset

, handles higher order functions as and inputs provides a proof of completeness
\end_layout

\begin_layout Itemize
Symbolic execution for higher order functions for a limited untyped variant
 of PCF is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "nguyen2017higher"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Testing dependent types
\end_layout

\begin_layout Standard
There has been a long recognized need for testing in addition to proving
 in dependent type systems
\end_layout

\begin_layout Itemize
In 
\begin_inset CommandInset citation
LatexCommand cite
key "dybjer2003combining"
literal "false"

\end_inset

 a QuickCheck style framework was added to an earlier version of Agda
\end_layout

\begin_layout Itemize
QuickChick
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/QuickChick/QuickChick
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "denes2014quickchick"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lampropoulos2017generating,lampropoulos2017beginner,lampropoulos2018random"
literal "false"

\end_inset

 is a research project to add testing to Coq.
 However testing requires building types classes that establish the properties
 needed by the testing framework such as decidable equality.
 This is presumably out of reach of novice Coq users.
\end_layout

\begin_layout Section
Reservations
\end_layout

\begin_layout Subsection
Purity
\end_layout

\begin_layout Standard
The base language is pure in the Haskell sense
\begin_inset Foot
status open

\begin_layout Plain Layout
the only effects are non termination and unhandled exceptions.
\end_layout

\end_inset

, an thus has many of the usability issues of languages in that style.
 Handling effects in a principled convenient way in mainstream functional
 programming languages is an ongoing research effort.
 Notable areas of research include Algebraic Effects and Handlers, and Linear
 Type systems.
\end_layout

\begin_layout Standard
Effects have been combined with dependent types in a limited fashion with
 Hoare Type Theory (HTT)
\begin_inset CommandInset citation
LatexCommand cite
key "nanevski2005dependent"
literal "false"

\end_inset

 and ATS.
\end_layout

\begin_layout Standard
Combing effects with Full-Spectrum dependent types is substantially more
 difficult because effectful equality is hard to characterize for individual
 effects or effects in combination.
 Several attempts have been made, 
\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ahman2017handling,ahman2017fibred"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 but there is still a lot of work to be done.
\end_layout

\begin_layout Subsection
Implicit arguments
\end_layout

\begin_layout Standard
The base language currently has no mechanism for marking arguments implicit.
 Implicit arguments drastically improve the usability of dependent type
 systems, often taking the place of type inference in ML style languages.
 They have been left out of the base language so that alternatives can be
 explored.
\end_layout

\begin_layout Subsection
Dependent data
\end_layout

\begin_layout Standard
The current presentation of data in the base language is powerful but there
 are inconveniences:
\end_layout

\begin_layout Itemize
The base language is based on eliminators with an explicit motive.
 Nested pattern matching is not supported which is surprisingly subtle 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

 with dependent types.
\end_layout

\begin_layout Itemize
Data types in the base language support dependent indices, but not 
\begin_inset Quotes eld
\end_inset

Parameters
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
There is no reduction in expressiveness, but these features should be added
 to make the language more convenient.
\end_layout

\begin_layout Section
Status
\end_layout

\begin_layout Itemize
I have a prototype of the cast language supporting all features.
 However the casting of data types will need to be reworked.
 I believe I can prove all the properties on the sublanguage without data.
 I expect it is possible to prove the properties on the language with data
 as well, though I need to work through those details.
\end_layout

\begin_layout Itemize
Substantial work was completed on the proof-search for the extended abstract,
 though it will need to be revisited.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "C:/icfp/dtest/extended-abstract/dtest"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
