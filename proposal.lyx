#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{typesetting/latex8}
\usepackage{times}
\usepackage{color}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{amsmath, nicefrac}
\usepackage{amssymb, amsthm}
\usepackage{wrapfig}
\usepackage{algorithm, algorithmic}
\usepackage{setspace}
\usepackage{caption}
\usepackage{float}
\usepackage{afterpage}
\usepackage{typesetting/abstract}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{calc}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{footnote}
\usepackage{threeparttable}
\usepackage{colortbl}
% \usepackage{tweaklist}
\usepackage{fancyhdr}
\usepackage[retainorgcmds]{IEEEtrantools}
\usepackage{floatflt}
\usepackage{xspace}

\usepackage{endnotes}
\usepackage{paralist}
\usepackage{typesetting/shortcuts}
\usepackage{tabulary}
\usepackage{mdwlist}
\usepackage{listings}
\usepackage{balance}
\usepackage{url}
\usepackage{parskip}
\usepackage{textcomp}
\usepackage{subcaption}

\usepackage{epstopdf}
\usepackage{fancyvrb}
% \usepackage[T1]{fontenc}

%-------------------------------------------------------------------------

%double spacing for document
\iffalse
\renewcommand{\textfraction}{0.1}
\renewcommand{\topfraction}{0.95}
\renewcommand{\bottomfraction}{0.95}
\renewcommand\floatpagefraction{0.9}
\setcounter{totalnumber}{50} \setcounter{topnumber}{50} \setcounter{bottomnumber}{50}
\renewcommand{\floatsep}{10pt}
\renewcommand{\intextsep}{10pt}
\setlength{\textfloatsep}{10pt}

\renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt}

\newcommand{\eqnlinespace}{\\[5pt]}
\newcommand{\eqnlinespacelarge}{\\[10pt]}
\newcommand{\captionlinespace}{\\[0.05in]}

\renewcommand{\baselinestretch}{1.6}

%\renewcommand{\textwidth}{5.95in}
\setlength{\textwidth}{6.875in}

\renewcommand{\oddsidemargin}{0.5in}
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_preamble
\options 12pt
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing double
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
em Dissertation Prospectus}
\backslash

\backslash
 
\end_layout

\end_inset

 A Full-Spectrum Dependently Typed Language for Programming with Dynamic
 Equality, Testing, and Runtime Proof Search
\end_layout

\begin_layout Author
Mark Lemay
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash
 Department of Computer Science, Boston University 
\backslash

\backslash
 
\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Dependent type systems are a powerful tool to eliminate bugs from programs.
 Unlike other systems of formal methods, dependent types systems can re-use
 the syntax and methodology that functional programmers are already familiar
 with for the construction of formal proofs.
 This insight has lead to several full-spectrum dependently typed languages
 that try to present programmers with a consistent view of proofs and programs.
 However, these languages still have substantial usability issues: missing
 features like general recursion, confusingly conservative equality, and
 no straightforward way to test and use properties that have not yet been
 proven.
\end_layout

\begin_layout Abstract
These issues are not superficial, but are tied to some of the conventional
 assumptions of dependent type theory.
 Logical soundness is essential when dependent type systems are used as
 a mathematical foundation, but may be too restrictive in a programming
 language.
 Conservative equality is easy to hand-wave away informally, but it makes
 many reasonable programs not type check.
 Users often experience these language properties as inexplicable static
 errors, and cannot debug their programs using conventional dynamic techniques.
 In practice, exploratory programming can be difficult in these systems.
\end_layout

\begin_layout Abstract
My solution to these problems is a dependent type system that is as permissive
 as possible and designed to produce clear feedback.
 The first part of my system is a dependently typed 
\begin_inset Quotes eld
\end_inset

surface
\begin_inset Quotes erd
\end_inset

 language with programmatic features that supports type sound, but logically
 unsound execution.
 This 
\begin_inset Quotes eld
\end_inset

surface
\begin_inset Quotes erd
\end_inset

 language can then be generalized into a dynamic 
\begin_inset Quotes eld
\end_inset

cast
\begin_inset Quotes erd
\end_inset

 language provisionally accepting many more equalities.
 Programmers in this system trade poor static errors for precise counterexamples
 that are made available at runtime.
 Additionally, automated testing can provide feedback about the correctness
 of typing whether the programmer intends to create a formal proof, or merely
 assert a property holds.
 Finally, a runtime proof search feature will allow programmers to take
 advantage of this machinery for prototyping.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% term search?
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Currently, the surface language is implemented and the cast language implementat
ion is being polished.
 Several properties have been proven for the system.
 Earlier prototypes of for automated testing and runtime proof search will
 need to be rewritten to accommodate changes changes to the cast language.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The Curry-Howard correspondence identifies functions with theorems, providing
 a mutually beneficial link between well explored areas of math and software
 engineering.
 This connection is most pronounced in dependent typed systems that provide
 a common language to write programs about proofs and proofs about programs.
 Specifically, dependent type systems allow types to depend on terms, supporting
 an extremely powerful system of specification, computation, and proof evidence.
 
\end_layout

\begin_layout Standard
For instance, in a dependently typed language it is possible to implement
 a provably correct sorting function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
sort\,:\,\left(input:List\,\mathbb{N}\right)\rightarrow\Sigma ls:List\,\mathbb{N}.IsSorted\,input\,ls
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

by providing an appropriate term of that type.
 Unlike other systems of formal methods, the additional logical power does
 not require the programmer understand any additional syntax or semantics.
 From the programmer's perspective, the function arrow and the implication
 arrow are the same.
 The proof 
\begin_inset Formula $IsSorted$
\end_inset

 is no different then any other term of a datatype like 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $List$
\end_inset

 or 
\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\end_layout

\begin_layout Standard
The promise of dependent types in a practical programming language has inspired
 research projects for decades.
 There have been many formalizations and prototypes that make different
 compromises in the design space.
 One of the most popular styles is 
\begin_inset Quotes eld
\end_inset

full-spectrum
\begin_inset Quotes erd
\end_inset

 dependent types, these languages tend to have a minimalist approach: computatio
n can appear anywhere in a term or type.
 Such a design purposely exposes the Curry-Howard correspondence, as opposed
 to merely using it as a convenient logical foundation: a proof has the
 exact same syntax and behavior as a program.
 Even though this style makes writing efficient programs hard, and drastically
 complicates the ability to use effects, it can be seen in some of the most
 popular dependently typed programming languages such as Agda and Idris.
\end_layout

\begin_layout Standard
Despite the potential, programmers often find these systems difficult to
 use.
 Consider the confusing error messages these languages are known to produce.
 For instance, in Agda this reasonable looking program 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathtt{Vec} & :*\rightarrow\mathbb{N}\rightarrow*\\
\mathtt{rep} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec\,\mathbb{B}}\,x\\
\mathtt{head} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec}\,\mathbb{B}\,\left(1+x\right)\rightarrow\mathbb{B}\\
\cancel{\vdash} & \lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

will give the error 
\begin_inset Quotes eld
\end_inset

x + 1 != suc x of type 
\begin_inset Formula $\mathbb{N}$
\end_inset

 when checking that the expression rep (x + 1) has type Vec 
\begin_inset Formula $\mathbb{B}$
\end_inset

 (1 + x)
\begin_inset Quotes erd
\end_inset

.
 The error is confusing since it objects to an intended property of addition,
 without telling why that property might not hold.
 If addition had a bug such that 
\begin_inset Formula $x+1\neq1+x$
\end_inset

 , no hints are given to fix the problem.
 While an expert in type theory can appreciate the subtleties of definitional
 equality, programmers would prefer an error message that gives a specific
 instance of 
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x+1\neq1+x$
\end_inset

 or be allowed to run their program.
 
\end_layout

\begin_layout Standard
Strengthening the equality relation in dependently typed languages has been
 the goal for many research projects (to name a few 
\begin_inset CommandInset citation
LatexCommand cite
key "HoTTbook,cockx2021taming,sjoberg2015programming"
literal "false"

\end_inset

).
 However, it is unlikely those impressive efforts are suitable for non-experts.
 Programmers unfamiliar with dependent type theory will expect the data
 types and functions they define to have the properties they were intended
 to have.
 None of these projects make the underlying equality less complicated.
 No system will be able to verify every 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equality for arbitrary user defined data types and functions statically,
 since program equivalence is famously undecidable.
\begin_inset ERT
status open

\begin_layout Plain Layout

% add hetro-eq if refferences don't count against page numbers
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, we could assume the equalities hold and discover a concrete
 witness of inequality as a runtime error.
 There is some evidence that specific examples like this can help clarify
 the error messages in OCaml
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2951913.2951915"
literal "false"

\end_inset

 and there has been an effort to make refinement type error messages more
 concrete and other systems like Liquid Haskell
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

.
 This leads to a different workflow then traditional type systems, instead
 of type checking first and only then executing the program, execution and
 type checking can both inform the programmer.
\end_layout

\begin_layout Standard
Several steps have been taken to make this new workflow a reality.
 Section 2 will describe a conventional dependently typed 
\begin_inset Quotes eld
\end_inset

surface
\begin_inset Quotes erd
\end_inset

 language with some programmatic features.
 Section 3 describes an extension to surface language that supports dynamic
 equality via casts.
 Section 4 covers some of the other features a language in this style will
 support.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% progress has been separated into several independent results
\end_layout

\end_inset


\end_layout

\begin_layout Section
A Dependently Typed Surface Language
\end_layout

\begin_layout Standard
The dynamic dependent equality of the later sections is hard to study without
 a more conventional dependently typed language to serve as a reference.
 This 
\begin_inset Quotes eld
\end_inset

surface
\begin_inset Quotes erd
\end_inset

 language provides the syntax that the programmer interacts with and a type
 theory that they can reason about.
 
\end_layout

\begin_layout Standard
The surface language contains the key features that should be supported
 for functional programming: user defined dependent functions and dependent
 datatypes.
 The surface language is built in a 
\begin_inset Quotes eld
\end_inset

full-spectrum
\begin_inset Quotes erd
\end_inset

 style.
 The 
\begin_inset Quotes eld
\end_inset

cast
\begin_inset Quotes erd
\end_inset

 language from the next section can be elaborated from and compared to this
 language.
\end_layout

\begin_layout Standard
The surface language is pure in the sense of Haskell, supporting only non-termin
ation and unchecked errors as effects.
 Combining other effects with full-spectrum dependent types is substantially
 more difficult because effectful equality is hard to characterize for individua
l effects and especially hard for effects in combination.
 Several attempts have been made to combine dependent types with more effects
 
\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ahman2017handling,ahman2017fibred"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 but there is still a lot of work to be done.
 General effects, though undoubtedly useful, will not be considered in this
 proposal.
\end_layout

\begin_layout Standard
Since this work emphasizes programming over theorem proving, the language
 contains these logically dubious features:
\end_layout

\begin_layout Itemize
Unrestricted recursion (no required termination checking)
\end_layout

\begin_layout Itemize
Type-in-Type (no hierarchy of universes)
\end_layout

\begin_layout Itemize
Unrestricted user defined dependent data types (no requirement of strict
 positivity)
\end_layout

\begin_layout Standard
Any one of these features can result in logical unsoundness
\begin_inset Foot
status open

\begin_layout Plain Layout
Every type is inhabited by an infinite loop.
\end_layout

\end_inset

, but they seem useful for mainstream functional programming.
 Additionally, non-termination causes type-checking to be undecidable, though
 this has not caused any issues in practice, and even decidable type-checking
 in dependent type theory is computationally intractable.
 In spite of logical unsoundness, the resulting language still has type
 soundness
\begin_inset Foot
status open

\begin_layout Plain Layout
No term typed in an empty context will 
\begin_inset Quotes eld
\end_inset

get stuck
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Logical soundness seems not to matter in programming practice.
 For instance, in ML the type 
\begin_inset Formula $\mathtt{f:Int->Int}$
\end_inset

 does not imply the termination of 
\begin_inset Formula $\mathtt{f\,2}$
\end_inset

.
 While unproductive non-termination is always a bug, it seems an easy bug
 to detect and fix when it occurs.
 In mainstream languages, types help to communicate the intent of termination,
 even though termination is not guaranteed by the type system.
 Therefore, logical unsoundness seems suitable for a dependently typed programmi
ng language since proofs can still be encoded and logical unsoundness can
 be discovered through traditional testing, or warned about in a non-blocking
 way.
 Importantly, no desirable computation is prevented in order to preserve
 logical soundness.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% bidirectionality
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The surface language uses bidirectional type checking to minimize the number
 of annotations required (
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3450952"
literal "false"

\end_inset

 is a good survey of the technique).
 Bidirectional type-checking is a popular technique for implementing dependently
 typed programming languages because it not as complicated as more sophisticated
 unification strategies, while still minimizing the annotations needed.
 This style of type checking usually only needs top level functions to be
 annotated
\begin_inset Foot
status open

\begin_layout Plain Layout
Even in Haskell, with full Hindley-Milner type inference, top level type
 annotations are encouraged.
\end_layout

\end_inset

.
 Bidirectional type-checking splits the typing judgment into 2 separate
 judgments: the 
\begin_inset Quotes eld
\end_inset

infer
\begin_inset Quotes erd
\end_inset

 judgment if the type can be inferred from a term, and a 
\begin_inset Quotes eld
\end_inset

check
\begin_inset Quotes erd
\end_inset

 judgment for when term will be checked against a type.
 Inferences can be turned into checked judgments with an explicit equality
 check.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO type soundness?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In spite of logical unsoundness, the surface language still supports a partial
 correctness property for first order data types when run with Call-by-Value.
 For instance,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\mathtt{IsEven}\,x
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset


\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 may not terminate, but if it does, 
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 will be an even 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 However, this property does not extend to functions
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\left(y:\mathbb{N}\right)\rightarrow x\leq y
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

it is possible that 
\begin_inset Formula $\mathtt{fst}\,M\equiv7$
\end_inset

 if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M\equiv\left\langle 7,\lambda y.\mathtt{loopForever}\right\rangle 
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Prior Work
\end_layout

\begin_layout Standard
While many of these features have been explored in theory and implemented
 in practice, I am unaware of any development with exactly this formulation.
\end_layout

\begin_layout Standard
Unsound logical systems that are acceptable programming languages go back
 to at least Church's lambda calculus which was originally intended to be
 a logical foundation for mathematics.
 In the 1970s, Martin Lof proposed a system with Type-in-Type that was shown
 logically unsound by Girard (as described in the introduction in 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin-Lof-1972"
literal "false"

\end_inset

).
 In the 1980s, Cardelli explored the domain semantics of a system with general
 recursive dependent functions and Type-in-Type
\begin_inset CommandInset citation
LatexCommand cite
key "cardelli1986polymorphic"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
The first direct proof of type soundness for a language with general recursive
 dependent functions, Type-in-Type, and dependent data that I am aware of
 came form the Trellys Project 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

.
 At the time their language had several additional features not included
 in my surface language.
 Additionally, my surface language uses a simpler notion of equality and
 dependent data resulting in an arguably simpler proof of type soundness.
 Later work in the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 used modalities to separate terminating and non-terminating fragments of
 the language, to allow both general recursion and logically sound reasoning
\begin_inset ERT
status open

\begin_layout Plain Layout

%, though the annotation burden seems high in retrospect
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 .
 In general, the base language has been deeply informed by the Trellys project
\begin_inset CommandInset citation
LatexCommand cite
key "kimmell2012equational"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015programming"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 and the Zombie language
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/sweirich/trellys
\end_layout

\end_inset

 it produced.
\end_layout

\begin_layout Standard
Several implementations support this combination of features without proofs
 of type soundness.
 Coquand presented an early bidirectional algorithm to type-check a similar
 language 
\begin_inset CommandInset citation
LatexCommand cite
key "COQUAND1996167"
literal "false"

\end_inset

.
 Cayenne 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/289423.289451"
literal "false"

\end_inset

 is a Haskell like language that combined dependent types with type-in-type,
 data and non-termination.
 Agda supports general recursion and type-in-type with compiler flags, and
 can simulate some non-positive data types using coinduction.
 Idris supports similar 
\begin_inset Quotes eld
\end_inset

unsafe
\begin_inset Quotes erd
\end_inset

 features.
\end_layout

\begin_layout Standard
A similar 
\begin_inset Quotes eld
\end_inset

partial correctness
\begin_inset Quotes erd
\end_inset

 criterion for dependent languages with non-termination run with Call-by-Value
 is presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "jia2010dependent"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
A Language with Dynamic Type Equality
\end_layout

\begin_layout Standard
A fundamental issue with dependent type theories is the characterization
 of definitional equality.
 Since computation can appear at the type level, and types must be checked
 for equality, dependent type theories must define what computations they
 intend to equate for type checking.
 For instance, the surface language follows the common choice of 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence of terms.
 However, this causes many acceptable programs to not type-check.
 For instance, 
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 will not type-check since 
\begin_inset Formula $1+x$
\end_inset

 does not have the same normalized syntax as 
\begin_inset Formula $x+1$
\end_inset

.
\end_layout

\begin_layout Standard
This is a widely recognized issue with dependent type theories.
 However, most attempts to improve the equality relation intend to preserve
 decidable type checking and/or logical soundness, so equality will never
 be complete
\begin_inset Foot
status open

\begin_layout Plain Layout
I am unaware of any suitable notion of complete extensional equality for
 dependent type theory though it is considered briefly in 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 .
\end_layout

\end_inset

.
 Since dependently typed languages with the practical features outlined
 in surface language are already incompatible with logical soundness and
 decidable type checking, these concerns no longer apply.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO definition, Notably, both the assumed and underlying type must always
 be known, so that casts can distribute over function application.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The surface language can be extended to a cast language that supports the
 expectation of the surface level typing.
 Many programs that do not type in the surface language can be elaborated
 into the cast language.
 The cast language has a weaker notion of type soundness, called cast soundness,
 such that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash a:A$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $a$
\end_inset

 is a value
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $a\rightsquigarrow a'$
\end_inset

 where 
\begin_inset Formula $\vdash a':A$
\end_inset


\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $a$
\end_inset

can blame a source location with a specific witness of inequality
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

In short, type soundness holds, or a good error message can be given.
 In the example above 
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 will not cause any type checking errors or runtime errors (though a static
 warning may be given).
 
\end_layout

\begin_layout Standard
If the example is changed to
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,x\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

and the function is called at runtime, the blame tracking system will blame
 the source location that uses unequal types with a direct proof of inequality,
 allowing an error like 
\begin_inset Quotes eld
\end_inset

failed at application 
\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\mathtt{head}\,x:\mathtt{Vec}\,\underline{\left(1+x\right)}\,\mathbb{B}\rightarrow...\right)\left(rep\,x:\mathtt{Vec}\,\underline{x}\,\mathbb{B}\right)$
\end_inset

 since when 
\begin_inset Formula $x=3$
\end_inset

, 
\begin_inset Formula $1+x=4\neq3=x$
\end_inset


\begin_inset Quotes erd
\end_inset

, regardless of when the function was called in the program and where the
 discrepancy was discovered.
\end_layout

\begin_layout Standard
Cast soundness improves on the naive solution of ignoring type annotations
 for execution, since without type soundness, the returned error may appear
 unrelated to the problematic type assumption (
\begin_inset Quotes eld
\end_inset

3 applied to 7 but 7 is not a function
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard
Just as standard type theories allow many possible characterizations of
 equality that support logical soundness, there are many choices of runtime
 checking that support this weaker notion of cast soundness.
 The minimal choice is likely too permissive in practice: in the example
 above, it would only flag an error when the function is applied to 
\begin_inset Formula $0$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% actaully it's more sbtle then that
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 .
 Alternatively, I believe that runtime-checking that matches the partial
 correctness criteria above would be reasonably intuitive.
 Extending checks into non-dependent function types also seems reasonable,
 and would allow simple types to be completely checked.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% elaboration
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Possibly untyped) terms in the surface language need to be converted into
 well-cast terms of the cast language.
 To do this I have defined an elaboration procedure that maintains the informati
on required to preserve cast checking.
 The elaboration procedure is inspired by bidirectional typing to track
 the locations that 
\begin_inset Quotes eld
\end_inset

assert
\begin_inset Quotes erd
\end_inset

 type level equalities.
 There are several basic properties that hold when terms of the surface
 language elaborate into terms of the cast language.
\end_layout

\begin_layout Enumerate
The elaboration procedure only produces well cast terms
\end_layout

\begin_layout Enumerate
Every term typed in the surface language elaborates
\end_layout

\begin_layout Enumerate
Errors are not spurious, errors never point to anything that type-checked
 in the surface language
\end_layout

\begin_layout Enumerate
Whenever an elaborated cast term evaluates, the corresponding surface term
 evaluates consistently
\end_layout

\begin_layout Subsection
Prior Work
\end_layout

\begin_layout Standard
It is unsurprising that dynamic equality shares many of the same concerns
 as the large amount of work for contracts, hybrid types, gradual types,
 and blame.
 In fact, this work could be seen as gradualizing the Reflection Rule in
 Extensional Type Theory.
\begin_inset ERT
status open

\begin_layout Plain Layout

% cite ETT?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Blame has been strongly advocated for in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-00590-9_1,wadler:LIPIcs:2015:5033"
literal "false"

\end_inset

.
 Blame tracking can help establish the reasonableness of contract monitoring
 systems by linking a dynamic failure directly to the broken invariant in
 source.
 Blame is also a key ingredient of clear runtime error messages.
 However, as many authors have noticed, proving blame correctness is tedious
 and error prone, it is often only conjectured.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% I have avioded this with dirty hacks
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The elaboration conditions are inspired by the Gradual Guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031"
literal "false"

\end_inset

.
 The implementation also takes inspiration from 
\begin_inset Quotes eld
\end_inset

Abstracting gradual typing
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2837614.2837670"
literal "false"

\end_inset

, where static evidence annotations become runtime checks.
 Unlike some impressive attempts to gradualize the polymorphic lambda calculus
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3110283"
literal "false"

\end_inset

, the cast language does not attempt to preserve any parametric properties
 of the surface language.
 It is unclear if such a restriction to parametric properties would be desirable
 for a dependently typed language.
\end_layout

\begin_layout Standard
A direct attempt has been made to gradualize a full-spectrum dependently
 typed language to an untyped lambda calculus using the AGT philosophy in
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3341692"
literal "false"

\end_inset

.
 However that system retains the intentional style of equality and user
 defined data types are not supported.
 That paper is largely concerned with establishing decidable type checking
 via an approximate term normalization.
\end_layout

\begin_layout Standard
A refinement type system with higher order features is gradualized in 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 though it does not appear powerful enough to be characterized as a full-spectru
m dependent type theory.
 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 builds on earlier refinement type system work, which described itself as
 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

.
 A notable example of dynamic checks in a refinement type system, is 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/1-4020-8141-3_34"
literal "false"

\end_inset

 which describes a refinement system that limits predicates to base types.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% clean up refinement type paragraph
\end_layout

\end_inset


\end_layout

\begin_layout Section
Further Features
\end_layout

\begin_layout Standard
Dynamic equality appears to be a prerequisite for other useful features.
\end_layout

\begin_layout Subsection
Prototyping Proofs and Programs
\end_layout

\begin_layout Standard
Just as 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equalities are missing from the definitional relation, 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 proofs and programs are not always conveniently available to the programmer.
 For instance, in Agda it is possible to write a sorting function quickly
 using simple types.
 With effort is it possible to prove that sorting procedure correct by rewriting
 it with the necessarily dependently typed invariants.
 However, very little is offered in between.
 The problem is magnified if module boundaries hide the implementation details
 of a function, since those details are exactly what is needed to make a
 proof! This is especially important for larger scale software where a library
 may require proof terms that while 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 are not constructable from the exports of other libraries.
\end_layout

\begin_layout Standard
The solution proposed here is additional syntax that will search for a term
 of the type when resolved at runtime.
 Given the sorting function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{sort}:\mathtt{List}\,\mathbb{N}\rightarrow\mathtt{List}\,\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

and given the first order predicate that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{IsSorted}:\mathtt{List}\,\mathbb{N}\rightarrow*
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

then it is possible to assert that 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 behaves as expected with
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.?:\left(x:\mathtt{List}\,\mathbb{N}\right)\rightarrow\mathtt{IsSorted}\left(\mathtt{sort}x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

This term will act like any other function at runtime, given a 
\begin_inset Formula $\mathtt{List}$
\end_inset

 input the function will verify that the 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 correctly handled that input, give an error, or non-terminate.
\end_layout

\begin_layout Standard
Additionally, this would allow simple prototyping form first order specification.
 For instance,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
data\ \mathtt{Mult} & :\mathbb{N}\rightarrow\mathbb{N}\rightarrow\mathbb{N}\rightarrow*\ where\\
\mathtt{base} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Mult}\ 0\ x\ 0\\
\mathtt{suc} & :\left(x\,y\,z:\mathbb{N}\right)\rightarrow\mathtt{Mult}\,x\,y\,z\rightarrow\mathtt{Mult}\,\left(1+x\right)\,y\,(y+z)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

can be used to prototype
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{div}=\lambda z.\lambda x.\mathtt{fst}\left(?:\sum y:\mathbb{N}.\mathtt{Mult}x\,y\,z\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

The term search can be surprisingly subtle.
 For instance,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
?:\sum f:\mathbb{N}\rightarrow\mathbb{N}.\mathtt{Id}\left(f,\lambda x.x+1\right)\&\mathtt{Id}\left(f,\lambda x.1+x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

depends on the definitional properties of functions.
 To avoid this subtly I plan to only support term search over first order
 data.
\end_layout

\begin_layout Subsubsection
Prior Work
\end_layout

\begin_layout Standard
Proof search is often used for static term generation in dependently typed
 languages (for instance Coq tactics).
 A first order theorem prover is attached to Agda in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

.
 However it is rare to make those features available at runtime.
 
\end_layout

\begin_layout Standard
Logic programing languages such as Prolog
\begin_inset Foot
status open

\begin_layout Plain Layout
https://www.swi-prolog.org/
\end_layout

\end_inset

, Datalog
\begin_inset Foot
status open

\begin_layout Plain Layout
https://docs.racket-lang.org/datalog/
\end_layout

\end_inset

, and miniKanren
\begin_inset Foot
status open

\begin_layout Plain Layout
http://minikanren.org/
\end_layout

\end_inset

 use 
\begin_inset Quotes eld
\end_inset

proof search
\begin_inset Quotes erd
\end_inset

 as their primary method of computation.
 However I am not aware of any system that combines logical programming
 with full-spectrum dependent types.
 The Twelf project
\begin_inset Foot
status open

\begin_layout Plain Layout
http://twelf.org/wiki/Main_Page
\end_layout

\end_inset

 makes use of runtime proof search and has some support for dependent types,
 but the underling theory cannot be considered full-spectrum.
 
\end_layout

\begin_layout Subsection
Testing Dependent Programs
\end_layout

\begin_layout Standard
Both dynamic equalities and dynamic proof search vastly weaken the guarantees
 of normal dependent type systems.
 Programmers still would like evidence of correctness, even while they intend
 to provide full proofs in the future.
 However, there are few options available in full-spectrum dependently typed
 languages aside from costly and sometimes unconstructable proofs.
\end_layout

\begin_layout Standard
The mainstream software industry has a similar need for evidence of correctness,
 and has standardized on testing done in a separate execution phase.
 Given the rich specifications that dependent types provide it is possible
 to improve on the hand crafted tests used by most of the industry.
 Instead we can use a type directed symbolic execution, to test questionable
 equalities over concrete values and precompute the searches of proof terms.
 Precomputed proof terms can be cached, so that exploration is not too inefficie
nt at runtime, at least in the common searched cases.
 Precomputed terms can be made available at runtime, excusing the inefficient
 search procedure.
 
\end_layout

\begin_layout Standard
Interestingly dynamic equality check is necessary for testing like this
 to be managable, since otherwise, definitional properties of functions
 would need to be accounted for.
 My previous attempts to test dependent specifications were overwhelmed
 by definitional considerations.
 Using dynamic equality it is possible to only consider the extensional
 behavior of functions.
\end_layout

\begin_layout Standard
Finally, future work can add more advanced methods of testing and proof
 generation.
 This architecture should make it easier to change exploration and search
 procedures without changing the underlining definitional behavior.
\end_layout

\begin_layout Subsubsection
Prior Work: Symbolic Execution
\end_layout

\begin_layout Standard
Most research for Symbolic Execution targets popular imperative languages
 (like C) and uses SMT solvers to efficiently explore conditional branches
 that depend on base types.
 Most work does not support higher order functions or makes simplifying
 assumptions about the type system.
 There are however some relevant papers:
\end_layout

\begin_layout Itemize
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

 presents a symbolic execution engine supporting Haskell's lazy execution
 and type system.
 Higher order functions are not handled
\end_layout

\begin_layout Itemize
The draft work
\begin_inset CommandInset citation
LatexCommand cite
key "2006.11639"
literal "false"

\end_inset

, handles higher order functions as inputs and provides a proof of completeness
\end_layout

\begin_layout Itemize
Symbolic execution for higher order functions for an untyped variant of
 PCF is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "nguyen2017higher"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Prior Work: Testing Dependent Types
\end_layout

\begin_layout Standard
There has been a long recognized need for testing in addition to proving
 in dependent type systems
\end_layout

\begin_layout Itemize
In 
\begin_inset CommandInset citation
LatexCommand cite
key "dybjer2003combining"
literal "false"

\end_inset

 a QuickCheck style framework was added to an earlier version of Agda
\end_layout

\begin_layout Itemize
QuickChick
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/QuickChick/QuickChick
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "denes2014quickchick"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lampropoulos2017generating,lampropoulos2017beginner,lampropoulos2018random"
literal "false"

\end_inset

 is a research project to add testing to Coq.
 However, testing requires building types classes that establish the properties
 needed by the testing framework such as decidable equality.
 This is presumably out of reach of novice Coq users.
\end_layout

\begin_layout Section
Status and Plan
\end_layout

\begin_layout Subsection
Status
\end_layout

\begin_layout Standard
The surface language has been fully implemented.
 I have proven type soundness for the full surface language (follows a similar
 structure to 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

), Qiancheng Fu has mechanized my proof of type soundness for the function
 fragment in Coq.
 Details are in a paper currently under submission at TyDe workshop.
\end_layout

\begin_layout Standard
An implementation for the cast language and elaboration procedure is almost
 completed.
 All properties mentioned in section 2 have been proven for the functional
 fragment.
 Qiancheng Fu has mechanized my proof of cast soundness in Coq.
 We conjecture that they can be extended to the full language with data.
\end_layout

\begin_layout Standard
A primitive proof search and a testing framework were implemented in an
 earlier prototype, but will need to be reimplemented to account for dynamic
 equality.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Plan
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO better as table? or force onto the last page
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
June
\end_layout

\begin_deeper
\begin_layout Itemize
clean up implementation
\end_layout

\begin_layout Itemize
write chapters: on the surface language, and on the cast language
\end_layout

\end_deeper
\begin_layout Itemize
July
\end_layout

\begin_deeper
\begin_layout Itemize
finalize the implementation of symbolic execution
\end_layout

\begin_layout Itemize
rework symbolic execution from
\begin_inset CommandInset citation
LatexCommand cite
key "extendedabstract"
literal "false"

\end_inset

 to use dynamic equality
\end_layout

\begin_layout Itemize
write chapter: testing and symbolic execution
\end_layout

\end_deeper
\begin_layout Itemize
August
\end_layout

\begin_deeper
\begin_layout Itemize
finalize the implementation of runtime proof search
\end_layout

\begin_layout Itemize
rework symbolic execution
\begin_inset CommandInset citation
LatexCommand cite
key "extendedabstract"
literal "false"

\end_inset

 to use dynamic equality
\end_layout

\begin_layout Itemize
write chapter: runtime proof-search
\end_layout

\end_deeper
\begin_layout Itemize
September
\end_layout

\begin_deeper
\begin_layout Itemize
Write a medium sized example in the language
\end_layout

\begin_layout Itemize
Write A chapter walking thought that example
\end_layout

\end_deeper
\begin_layout Itemize
October
\end_layout

\begin_deeper
\begin_layout Itemize
Finalize: Introduction, Future work, Conclusion
\end_layout

\end_deeper
\begin_layout Itemize
November: Defend
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/dtest/extended-abstract/dtest"
options "bibtotoc,plain"

\end_inset


\end_layout

\begin_layout Section
Appendix
\end_layout

\begin_layout Subsection
Surface Language (the function fragment)
\end_layout

\begin_layout Subsubsection
Pre-syntax
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
source labels,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ensuremath{\ell}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable contexts,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lozenge$
\end_inset

 | 
\begin_inset Formula $\Gamma,x:M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expressions,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m,n,h,M,N,H$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m::_{\ensuremath{\ell}}M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
annotation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type universe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow m$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m_{\ensuremath{\ell}}\,n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow m$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Surface Language Judgments
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\Gamma\vdash m\overrightarrow{\,:\,}M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The type 
\begin_inset Formula $M$
\end_inset

 can be inferred form 
\begin_inset Formula $m$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\Gamma\vdash m\overleftarrow{\,:\,}M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The 
\begin_inset Formula $m$
\end_inset

 is checked against the type 
\begin_inset Formula $M$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x:M\in\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 is in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma$
\end_inset

with type 
\begin_inset Formula $M$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma\vdash$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Context 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 is well formed in the bidirectional system
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\Gamma\vdash m\,:\,M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 has type 
\begin_inset Formula $M$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma$
\end_inset

 via
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 type assignment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\Gamma\vdash m\equiv m'\,:\,M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $m'$
\end_inset

 share a reduct (ignoring location information)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\Gamma\vdash m\Rrightarrow m'\,:\,M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 goes to 
\begin_inset Formula $m'$
\end_inset

 in 1 parallel step
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\Gamma\vdash m\Rrightarrow^{*}m'\,:\,M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 goes to 
\begin_inset Formula $m'$
\end_inset

 in 0 or more parallel steps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $m\rightsquigarrow m'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 goes to 
\begin_inset Formula $m'$
\end_inset

 in 1 small step
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $m\rightsquigarrow^{*}m'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 goes to 
\begin_inset Formula $m'$
\end_inset

 in 0 or more small steps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $m\,Stuck$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 is not a value and does not small step
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Only select definitions are given here, full definitions are available in
 a tech report.
 More polished variants are available in our TyDe submission, and Coq developmen
t.
\end_layout

\begin_layout Subsubsection
Bidirectional Type System
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{x:M\in\Gamma}{\Gamma\vdash x\overrightarrow{\,:\,}M}var-\overrightarrow{ty}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash m\overleftarrow{\,:\,}M\quad\Gamma\vdash M\overleftarrow{\,:\,}\star}{\Gamma\vdash m::_{\ell}M\overrightarrow{\,:\,}M}::-\overrightarrow{ty}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\Gamma\vdash\star\overrightarrow{\,:\,}\star}\star-\overrightarrow{ty}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash M\overleftarrow{\,:\,}\star\quad\Gamma,x:M\vdash N\overleftarrow{\,:\,}\star}{\Gamma\vdash\left(x:M\right)\rightarrow N\overrightarrow{\,:\,}\star}\Pi-\overrightarrow{ty}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash m\overrightarrow{\,:\,}\left(x:N\right)\rightarrow M\quad\Gamma\vdash n\overleftarrow{\,:\,}N}{\Gamma\vdash m\,n\overrightarrow{\,:\,}M\left[x\coloneqq n\right]}\Pi-app-\overrightarrow{ty}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash m\overleftarrow{\,:\,}M\quad\Gamma\vdash M\equiv M':\star}{\Gamma\vdash m\overrightarrow{\,:\,}M'}conv-\overrightarrow{ty}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma,f:\left(x:N\right)\rightarrow M,x:N\vdash m\overleftarrow{\,:\,}M}{\Gamma\vdash\mathsf{fun}\,f\,x\Rightarrow m\overleftarrow{\,:\,}\left(x:N\right)\rightarrow M}\Pi-\mathsf{fun}-\overleftarrow{ty}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Properties
\end_layout

\begin_layout Standard
Type Soundness, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\vdash m\overleftarrow{\,:\,}M$
\end_inset

 and for all 
\begin_inset Formula $m'$
\end_inset

, 
\begin_inset Formula $m\rightsquigarrow^{*}m'$
\end_inset

, then 
\begin_inset Formula $m'$
\end_inset

 is not 
\begin_inset Formula $Stuck$
\end_inset

.
\end_layout

\begin_layout Subsection
Cast Language (the function fragment)
\end_layout

\begin_layout Subsubsection
Pre-syntax
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable contexts,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lozenge$
\end_inset

 | 
\begin_inset Formula $H,x:A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
expressions,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a,b,c$
\end_inset

,
\begin_inset Formula $A,B,C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::_{A,\ensuremath{\ell}o}B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:A\right)\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow b$
\end_inset

 | 
\begin_inset Formula $b\,a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
 | 
\begin_inset Formula $o.arg$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function type-argument
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.bod[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function type-body
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Judgments
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $H\vdash a\,:\,A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 has type 
\begin_inset Formula $A$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $H$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x:A\in H$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 is in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $H$
\end_inset

 with type 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H\vdash$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Context 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $H$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 is well formed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $H\vdash a\equiv a'\,:\,A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $a'$
\end_inset

 share a reduct and have type 
\begin_inset Formula $A$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $H$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $a\Rrightarrow a'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 goes to 
\begin_inset Formula $a'$
\end_inset

 in 1 parallel step
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $a\Rrightarrow^{*}a'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 goes to 
\begin_inset Formula $a'$
\end_inset

 in 0 or more parallel steps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $a\rightsquigarrow a'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 goes to 
\begin_inset Formula $a'$
\end_inset

 in 1 small step
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $a\rightsquigarrow^{*}a'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 goes to 
\begin_inset Formula $a'$
\end_inset

 in 0 or more small steps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $a\:Val$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 is a value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $a\,Stuck$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 is not a value and does not small step
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Blame\:\ensuremath{\ell}\,o\,a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

 blames the location 
\begin_inset Formula $\ensuremath{\ell}$
\end_inset

 with observation 
\begin_inset Formula $o$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Parallel reductions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{b\Rrightarrow b'\quad a\Rrightarrow a'}{\left(\mathsf{fun}\,f\,x\Rightarrow b\right)a\Rrightarrow b'\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow b',x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{b\Rrightarrow b'\quad a\Rrightarrow a'\quad o\Rrightarrow o'\quad A_{1}\Rrightarrow A_{1}'\quad B_{1}\Rrightarrow B_{1}'\quad A_{2}\Rrightarrow A_{2}'\quad B_{2}\Rrightarrow B_{2}'}{\left(b::_{\left(x:A_{1}\right)\rightarrow B_{1},\ell o}\left(x:A_{2}\right)\rightarrow B_{2}\right)a\:\Rrightarrow\:\left(b'\,a'::_{A_{2}',\ensuremath{\ell}o'.arg}A_{1}'\right)::_{B_{1}\left[x\coloneqq a'::_{A_{2}',\ensuremath{\ell}o'.arg}A_{1}'\right],\ensuremath{\ell}o'.bod[a']}B_{2}'\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\Rrightarrow a'}{a::_{\star,\ensuremath{\ell}o}\star\Rrightarrow a'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{x\Rrightarrow x}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\Rrightarrow a'\quad A\Rrightarrow A'\quad B\Rrightarrow B'\quad o\Rrightarrow o'}{a::_{A,\ensuremath{\ell},o}B\Rrightarrow a'::_{A',\ensuremath{\ell},o'}B'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\star\Rrightarrow\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{A\Rrightarrow A'\quad B\Rrightarrow B'}{\left(x:A\right)\rightarrow B\Rrightarrow\left(x:A'\right)\rightarrow B'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{b\Rrightarrow b'}{\mathsf{fun}\,f\,x\Rightarrow b\,\Rrightarrow\,\mathsf{fun}\,f\,x\Rightarrow b'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{b\Rrightarrow b'\quad a\Rrightarrow a'}{b\,a\Rrightarrow b'\,a'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{o\Rrightarrow o'}{o\Rrightarrow o'.arg}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{o\Rrightarrow o'\quad a\Rrightarrow a'}{o.bod\left[a\right]\Rrightarrow o'.bod\left[a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{.\Rrightarrow.}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Definitional Equality
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{B\Rrightarrow B''\quad B'\Rrightarrow B''}{B\equiv B'}
\]

\end_inset


\end_layout

\begin_layout Standard
from the confluence and reflexivity of 
\begin_inset Formula $\Rrightarrow$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
, 
\begin_inset Formula $\equiv$
\end_inset

 is an equivalence (reflexive, commutative and transitive).
 Type constructors are definitionally unique, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\ast\bcancel{\equiv}\Pi$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 .
\end_layout

\begin_layout Subsubsection
Cast-Typing Rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{x:A\in H}{H\vdash x\,:\,A}var-cast
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash A:\star\quad H\vdash B:\star}{H\vdash a::_{A,\ensuremath{\ell},o}B\::\:B}::-cast
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{H\vdash\star:\,\star}\star-cast
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash A:\star\quad H,x:A\vdash B:\star}{H\vdash\left(x:A\right)\rightarrow B\,:\,\star}\Pi-cast
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H,f:\left(x:A\right)\rightarrow B,x:A\vdash b:B}{H\vdash\mathsf{fun}\,f\,x\Rightarrow b\,:\,\left(x:A\right)\rightarrow B}\Pi-\mathsf{fun}-cast
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash b:\left(x:A\right)\rightarrow B\quad H\vdash a:A}{H\vdash b\,a\,:\,B\left[x\coloneqq a\right]}\Pi-app-cast
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash A\equiv A':\star}{H\vdash a:A'}conv-cast
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Values
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\star\,Val}\star-Val
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left(x:A\right)\rightarrow B\,Val}\Pi-Val
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\mathsf{fun}\,f\,x\Rightarrow b\:Val}\Pi-\mathsf{fun}-Val
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
a\:Val\quad A\:Val\quad B\:Val\\
a\cancel{=}\star\\
a\cancel{=}\left(x:C\right)\rightarrow C'
\end{array}}{a::_{A,\ensuremath{\ell}o}B\:Val}::-Val
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Small Step Semantics
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\,Val}{\left(\mathsf{fun}\,f\,x\Rightarrow b\right)a\rightsquigarrow b\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow b,x\coloneqq a\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{b\,Val\quad a\,Val}{\begin{array}{c}
\left(b::_{\left(x:A_{1}\right)\rightarrow B_{1},\ensuremath{\ell}o}\left(x:A_{2}\right)\rightarrow B_{2}\right)a\rightsquigarrow\\
\left(b\,a::_{A_{2},\ell o.arg}A_{1}\right)::_{B_{1}\left[x\coloneqq a::_{A_{2},\ell o.arg}A_{1}\right],\ensuremath{\ell}o.bod[a]}B_{2}\left[x\coloneqq a\right]
\end{array}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\,Val}{a::_{\star,\ensuremath{\ell}o}\star\rightsquigarrow a}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\rightsquigarrow a'}{a::_{A,\ensuremath{\ell}o}B\rightsquigarrow a'::_{A,\ensuremath{\ell}o}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\,Val\quad A\rightsquigarrow A'}{a::_{A,\ensuremath{\ell}o}B\rightsquigarrow a::_{A',\ensuremath{\ell}o}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\,Val\quad A\,Val\quad B\rightsquigarrow B'}{a::_{A,\ensuremath{\ell}o}B\rightsquigarrow a::_{A,\ensuremath{\ell}o}B'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{b\rightsquigarrow b'}{b\,a\rightsquigarrow b'\,a}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{b\,Val\quad a\rightsquigarrow a'}{b\,a\rightsquigarrow b\,a'}
\]

\end_inset


\end_layout

\begin_layout Standard
as usual 
\begin_inset Formula $\frac{a\rightsquigarrow a'}{a\Rrightarrow a'}$
\end_inset

 is derivable.
 However it is not the case that 
\begin_inset Formula $\frac{a\Rrightarrow*a'}{a\rightsquigarrow*a'}$
\end_inset

 since the operational semantics does not evaluate under binders or in observati
ons.
\end_layout

\begin_layout Subsubsection
Blame
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{Blame\:\ensuremath{\ell}\,o\,a::_{\left(x:A\right)\rightarrow B,\ensuremath{\ell}o}\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{Blame\:\ensuremath{\ell}\,o\,a::_{\star,\ensuremath{\ell}o}\left(x:A\right)\rightarrow B}
\]

\end_inset


\end_layout

\begin_layout Standard
structural rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Blame\:\ensuremath{\ell}\,o\,a}{Blame\:\ensuremath{\ell}\,o\,a::_{A,\ensuremath{\ell'}o'}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Blame\:\ensuremath{\ell}\,o\,A}{Blame\:\ensuremath{\ell}\,o\,a::_{A,\ensuremath{\ell'}o'}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Blame\:\ensuremath{\ell}\,o\,B}{Blame\:\ensuremath{\ell}\,o\,a::_{A,\ensuremath{\ell'}o'}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Blame\:\ensuremath{\ell}\,o\,b}{Blame\:\ensuremath{\ell}\,o\,\left(b\,a\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Blame\:\ensuremath{\ell}\,o\,a}{Blame\:\ensuremath{\ell}\,o\,\left(b\,a\right)}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Properties
\end_layout

\begin_layout Standard
Cast Soundness, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\vdash a\,:\,A$
\end_inset

 and for all 
\begin_inset Formula $a'$
\end_inset

, 
\begin_inset Formula $a\rightsquigarrow^{*}a'$
\end_inset

, if 
\begin_inset Formula $a'\,Stuck$
\end_inset

 then there exists 
\begin_inset Formula $\ensuremath{\ell}$
\end_inset

, 
\begin_inset Formula $o$
\end_inset

 such that 
\begin_inset Formula $Blame\:\ensuremath{\ell}\,o\,a'$
\end_inset


\end_layout

\begin_layout Subsection
Elaboration (the function fragment)
\end_layout

\begin_layout Subsubsection
Judgments
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $H\vdash Elab\,m\,a\overrightarrow{\,:\,}A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 elaborates into 
\begin_inset Formula $a$
\end_inset

 with inferred type 
\begin_inset Formula $A$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $H$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H\vdash Elab\ n\,a\overleftarrow{\,:_{\ell o}\,}A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m$
\end_inset

 elaborates into 
\begin_inset Formula $a$
\end_inset

 with type 
\begin_inset Formula $A$
\end_inset

 because of 
\begin_inset Formula $\ell o$
\end_inset

 in 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $H$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Elab\,\Gamma\,H$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the context 
\begin_inset Formula $\Gamma$
\end_inset

 elaborates into 
\begin_inset Formula $\Gamma\,H$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Elaboration
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{x:A\in H}{H\vdash Elab\,x\,x\overrightarrow{\,:\,}A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{H\vdash Elab\,\star\,\star\overrightarrow{\,:\,}\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash Elab\ M\,A\overleftarrow{\,:_{\ell.}\,}\star\quad H,x:A\vdash Elab\ N\,B\overleftarrow{\,:_{\ell'.}\,}\star}{H\vdash Elab\,\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}\ \left(x:A\right)\rightarrow B\overrightarrow{\,:\,}\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash Elab\ m\,b\overrightarrow{\,:\,}C\quad C\equiv\left(x:A\right)\rightarrow B\quad H\vdash Elab\ n\,a\overleftarrow{\,:_{\ell.arg}\,}A}{H\vdash Elab\,m_{\ell}\,n\ b\,a\overrightarrow{\,:\,}B\left[x\coloneqq a\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash Elab\ M\,A\overleftarrow{\,:_{\ell.}\,}\star\quad H\vdash Elab\ m\,a\overleftarrow{\,:_{\ell.}\,}A}{H\vdash Elab\,m::_{\ell}M\ a\overrightarrow{\,:\,}A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash Elab\ m\,a\overrightarrow{\,:\,}A}{H\vdash Elab\,m\ a::_{A,\ensuremath{\ell}o}A'\overleftarrow{\,:_{\ell o}\,}A'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H,f:\left(x:A\right)\rightarrow B,x:A\vdash Elab\ m\,b\overleftarrow{\,:_{\ell o.bod[x]}\,}B}{H\vdash Elab\,\mathsf{fun}\,f\,x\Rightarrow m\ \mathsf{fun}\,f\,x\Rightarrow b\overleftarrow{\,:_{\ell o}\,}\left(x:A\right)\rightarrow B}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Erasure
\end_layout

\begin_layout Standard
This function that uniformly erases cast, location and type information
 from all variants of syntax
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|x|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\star|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m::_{\ell}M|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:|M|\right)\rightarrow|N|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m_{\ensuremath{\ell}}\,n|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m|\,|n|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\mathsf{fun}\,f\,x\Rightarrow m|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow|m|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\lozenge|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lozenge$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\Gamma,x:A|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\Gamma|,x:|A|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|a::_{A,M,\ensuremath{\ell},o,N}B|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|a|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\left(x:A\right)\rightarrow B|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:|A|\right)\rightarrow|B|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\mathsf{fun}\,f\,x\Rightarrow b|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow|b|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b\,a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|b|\,|a|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|H,x:M|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|H|,x:|M|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Properties
\end_layout

\begin_layout Standard
Elaboration preserves erasure
\end_layout

\begin_layout Itemize
for any 
\begin_inset Formula $Elab\,\Gamma\,H$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
then 
\begin_inset Formula $|H|=|\Gamma|$
\end_inset


\end_layout

\begin_layout Itemize
for any 
\begin_inset Formula $H\vdash Elab\,a\,m\overrightarrow{\,:\,}A$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
then 
\begin_inset Formula $|m|=|a|$
\end_inset


\end_layout

\begin_layout Itemize
for any 
\begin_inset Formula $H\vdash Elab\,a\,m\overleftarrow{\,:_{\ell o}\,}A$
\end_inset

,
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
then 
\begin_inset Formula $|m|=|a|$
\end_inset


\end_layout

\begin_layout Standard
Elaboration is always well-cast
\end_layout

\begin_layout Itemize
for any 
\begin_inset Formula $H\vdash Elab\,a\,m\overrightarrow{\,:\,}A$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
then 
\begin_inset Formula $H\vdash a:A$
\end_inset


\end_layout

\begin_layout Itemize
for any 
\begin_inset Formula $H\vdash Elab\,a\,m\overleftarrow{\,:_{\ell o}\,}A$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
then 
\begin_inset Formula $H\vdash a:A$
\end_inset


\end_layout

\begin_layout Standard
Terms that are bidirectionally typed elaborate
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $\Gamma\vdash m\overrightarrow{\,:\,}M$
\end_inset

 then there exists 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 such that 
\begin_inset Formula $\vdash Elab\ m\,a\overrightarrow{\,:\,}A$
\end_inset


\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $\Gamma\vdash m\overleftarrow{\,:\,}M$
\end_inset

 and given 
\begin_inset Formula $\ell$
\end_inset

 then there exists 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $o$
\end_inset

 such that 
\begin_inset Formula $H\vdash Elab\,a\,m\overleftarrow{\,:_{\ell o}\,}A$
\end_inset


\end_layout

\begin_layout Standard
Blame never points to something that checked in the bidirectional system
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $\vdash m\overrightarrow{\,:\,}M$
\end_inset

, and 
\begin_inset Formula $\vdash Elab\ m\,a\overrightarrow{\,:\,}A$
\end_inset

 , then for no
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $a\rightsquigarrow^{*}a'$
\end_inset

 will 
\begin_inset Formula $Blame\:\ensuremath{\ell}\,o\:a'$
\end_inset


\end_layout

\begin_layout Standard
Evaluation of elaboration is consistent with unelaborated evaluation
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $H\vdash Elab\ m\,a\overrightarrow{\,:\,}A$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
and 
\begin_inset Formula $a\rightsquigarrow^{*}\star$
\end_inset

 then 
\begin_inset Formula $m\rightsquigarrow^{*}\star$
\end_inset


\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $H\vdash Elab\ m\,a\overrightarrow{\,:\,}A$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
and 
\begin_inset Formula $a\rightsquigarrow^{*}(x:A)\rightarrow B$
\end_inset

 then there exists 
\begin_inset Formula $N$
\end_inset

, 
\begin_inset Formula $M$
\end_inset

,
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\ell$
\end_inset

, 
\begin_inset Formula $\ell$
\end_inset

'
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 such that 
\begin_inset Formula $m\rightsquigarrow^{*}(x:N_{\ell})\rightarrow M_{\ell'}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
