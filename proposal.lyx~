#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{typesetting/latex8}
\usepackage{times}
\usepackage{color}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{amsmath, nicefrac}
\usepackage{amssymb, amsthm}
\usepackage{wrapfig}
\usepackage{algorithm, algorithmic}
\usepackage{setspace}
\usepackage{caption}
\usepackage{float}
\usepackage{afterpage}
\usepackage{typesetting/abstract}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{calc}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{footnote}
\usepackage{threeparttable}
\usepackage{colortbl}
% \usepackage{tweaklist}
\usepackage{fancyhdr}
\usepackage[retainorgcmds]{IEEEtrantools}
\usepackage{floatflt}
\usepackage{xspace}

\usepackage{endnotes}
\usepackage{paralist}
\usepackage{typesetting/shortcuts}
\usepackage{tabulary}
\usepackage{mdwlist}
\usepackage{listings}
\usepackage{balance}
\usepackage{url}
\usepackage{parskip}
\usepackage{textcomp}
\usepackage{subcaption}

\usepackage{epstopdf}
\usepackage{fancyvrb}
% \usepackage[T1]{fontenc}

%-------------------------------------------------------------------------

%double spacing for document

\renewcommand{\textfraction}{0.1}
\renewcommand{\topfraction}{0.95}
\renewcommand{\bottomfraction}{0.95}
\renewcommand\floatpagefraction{0.9}
\setcounter{totalnumber}{50} \setcounter{topnumber}{50} \setcounter{bottomnumber}{50}
\renewcommand{\floatsep}{10pt}
\renewcommand{\intextsep}{10pt}
\setlength{\textfloatsep}{10pt}

\renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt}

\newcommand{\eqnlinespace}{\\[5pt]}
\newcommand{\eqnlinespacelarge}{\\[10pt]}
\newcommand{\captionlinespace}{\\[0.05in]}

\renewcommand{\baselinestretch}{1.6}

%\renewcommand{\textwidth}{5.95in}
\setlength{\textwidth}{6.875in}

\renewcommand{\oddsidemargin}{0.5in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_preamble
\options 11pt
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
em Dissertation Prospectus}
\backslash

\backslash
 
\end_layout

\end_inset

 A Full-Spectrum Dependently typed language for testing with dynamic equality
\end_layout

\begin_layout Author
Mark Lemay
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash
 Department of Computer Science, Boston University 
\backslash

\backslash
 
\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Dependent type systems are a powerful tool to eliminate bugs from programs.
 Unlike other systems of formal methods, dependent types systems can re-use
 the methodology and syntax that functional programmers are already familiar
 with for the construction of formal proofs.
 This insight has lead to several Full-Spectrum languages that try and present
 programmers with a consistent view of proofs and programs.
 However these languages still have substantial usability issues: missing
 features like general recursion, confusingly conservative equality, and
 no straight forward way to test specifications that have not yet been proven.
\end_layout

\begin_layout Abstract
These issues are not superficial, but are tied to some of the conventional
 assumptions of dependent type theory.
 Logical soundness is essential when dependent types are considered as a
 logic, but may be too restrictive in a programming language.
 Conservative equality is easy to hand-wave away informally, but it makes
 many programs unrunnable.
 Users often experience these characteristics as inexplicable static errors.
 In practice these foundational assumptions, make exploratory programming
 difficult.
\end_layout

\begin_layout Abstract
A possible solution is to design a dependently typed language with programmatic
 features that supports type sound, but logically unsound execution.
 Programmers can trade poor static errors, for precise counter examples
 that are made available at runtime.
 Progress towards that solution has been by developing a base language with
 programming oriented features, characterizing some correctness criteria,
 and implementing a subset of that language that matches those criteria.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The Curry-Howard correspondence identifies functions with theorems, providing
 a mutually beneficial link between well explored areas of math and software
 engineering.
 This connection is most pronounced in dependent typed systems that provide
 a common language to write programs about proofs and proofs about programs.
 Specifically, dependent type systems allow types to depend on terms, supporting
 an extremely powerful system of specification, computation and proof evidence.
 
\end_layout

\begin_layout Standard
For instance, in a dependently typed language it is possible to prove the
 correctness of a sorting function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
sort\,:\,\left(input:List\,\mathbb{N}\right)\rightarrow\Sigma ls:List\,\mathbb{N}.IsSorted\,input\,ls
\]

\end_inset


\end_layout

\begin_layout Standard
by providing an appropriate term of that type.
 Unlike other systems of formal methods, the additional logical power does
 not require the programmer understand any additional syntax or semantics.
 Form the programmer's perspective the function arrow and the implication
 arrow are the same.
 The proof 
\begin_inset Formula $IsSorted$
\end_inset

 is no different then any other datatype like 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $List$
\end_inset

 or 
\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\end_layout

\begin_layout Standard
The promise of dependent types in a practical programming language has been
 the goal of research projects for decades.
 There have been many formalization and prototypes that make different compromis
es in the design space.
 One of the most popular styles is 
\begin_inset Quotes eld
\end_inset

Full-spectrum
\begin_inset Quotes erd
\end_inset

 dependent types, these languages tend to have a minimalist approach: computatio
n can appear anywhere in a term or type.
 Such a design purposely exposes the Curry-Howard correspondence, as opposed
 to trying to hide it as a technical foundation: a proof has the exact same
 syntax and behavior as a program.
 Even though this style makes writing efficient programs hard, and drastically
 complicates the ability to encode effects, it can be seen in some of the
 most popular dependently typed languages such as Agda and Idris.
\end_layout

\begin_layout Standard
Despite the potential, users often find these systems difficult to use.
 The common symptom of these issues can be seen in the confusing error messages
 these languages produce.
 For instance in Agda this reasonable looking program 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathtt{Vec} & :*\rightarrow\mathbb{N}\rightarrow*\\
\mathtt{rep} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec\,\mathbb{B}}\,x\\
\mathtt{head} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Vec}\,\mathbb{B}\,\left(1+x\right)\rightarrow\mathbb{B}\\
\cancel{\vdash} & \lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
will give the error 
\begin_inset Quotes eld
\end_inset

x + 1 != suc x of type 
\begin_inset Formula $\mathbb{N}$
\end_inset

 when checking that the expression rep (x + 1) has type Vec 
\begin_inset Formula $\mathbb{B}$
\end_inset

 (1 + x)
\begin_inset Quotes erd
\end_inset

.
 The error is confusing since it objects to an intended property of addition,
 and if addition were buggy no hints are given to fix the problem.
 While an expert in Type Theory can appreciate the subtitles of definitional
 equality, programmers would prefer an error message that gives a specific
 instance of 
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x+1\neq1+x$
\end_inset

 or be allowed to run their program.
 
\end_layout

\begin_layout Standard
Strengthening the equality relation in dependently typed languages is used
 to motivate many research projects (to name a few 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx2021taming,sjoberg2015programming"
literal "false"

\end_inset

).
 However, it is unlikely those impressive efforts are suitable for non-exerts,
 since programmers expect the data types and functions they define to have
 the properties they were intended to have.
 None of these projects makes the underling equality less subtle and complicated.
 No system will be able to verify every 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equality for arbitrary user defined data types and functions statically,
 since program equivalence is famously undecidable.
\end_layout

\begin_layout Standard
Alternatively we could assume the equalities hold and discover a concrete
 inequality as a runtime error.
 There is some evidence that specific examples like this can help clarify
 the error messages in OCaml
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2951913.2951915"
literal "false"

\end_inset

 and there has been an effort to make refinement type error messages more
 concrete and other systems like Liquid Haskell
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

.
 This leads too a different workflow then traditional type systems, instead
 of verifying everything first and only then executing the program, execution
 and type checking can both inform the programmer.
\end_layout

\begin_layout Standard
To make this new workflow possible section 2 will describe a more traditional
 base language with some programmatic features.
 Section 3 describes dynamic dependent equality and the conditions that
 would make an implementation reasonable.
 Section 4 covers some of the other features a language in this style could
 support.
\end_layout

\begin_layout Section
A Dependently Typed Base Language
\end_layout

\begin_layout Standard
Dynamic dependent equality is hard to study without a more conventional
 dependently typed language to serve as a reference.
 This base language contains the key features that should be supported:
 user defined dependent functions and dependent datatypes.
 The base language uses a 
\begin_inset Quotes eld
\end_inset

Full-Spectrum
\begin_inset Quotes erd
\end_inset

 style.
 The dynamic language from the next section can be elaborated from and compared
 to this concrete implementation.
\end_layout

\begin_layout Standard
The language is pure in the sense of Haskell, supporting only non-termination
 and unchecked errors as effects.
 Combing other effects with Full-Spectrum dependent types is substantially
 more difficult because effectful equality is hard to characterize for individua
l effects or effects in combination.
 Several attempts have been made to combine dependent types with more effects,
 
\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ahman2017handling,ahman2017fibred"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "pedrot2020fire"
literal "false"

\end_inset

 but there is still a lot of work to be done, so it is not considered in
 the base language.
\end_layout

\begin_layout Standard
Since this work emphasizes programming over theorem proving the language
 contains these logically dubious features:
\end_layout

\begin_layout Itemize
Unrestricted user defined dependent data types (no requirement of strict
 positivity)
\end_layout

\begin_layout Itemize
Unrestricted recursion (no required termination checking)
\end_layout

\begin_layout Itemize
Type-in-type (no predictive hierarchy of universes)
\end_layout

\begin_layout Standard
Any one of these features can result in logical unsoundness
\begin_inset Foot
status open

\begin_layout Plain Layout
Every type is inhabited by an infinite loop.
\end_layout

\end_inset

, but they facilitate mainstream functional programming.
 In spite of the logical unsoundness, the resulting language still has type
 soundness
\begin_inset Foot
status open

\begin_layout Plain Layout
No term with a reduct that applies an argument to a non-function in the
 empty context will type.
\end_layout

\end_inset

.
 This seems suitable for a programming language since logically sound proofs
 can still be defined and logical unsoundness can be discovered through
 traditional testing, or warned about in a non-blocking way.
 Importantly no desirable computation is prevented.
\end_layout

\begin_layout Standard
Though this language is not logically sound, it supports a partial correctness
 property for first order data types when run with Call-by-Value, for instance:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\mathtt{IsEven}\,x
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 may not terminate, but if it does, 
\begin_inset Formula $\mathtt{fst}\,M$
\end_inset

 will be an even 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbb{N}$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 However, this property does not extend to functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vdash M:\,\sum x:\mathbb{N}.\left(y:\mathbb{N}\right)\rightarrow x\leq y
\]

\end_inset


\end_layout

\begin_layout Standard
it is possible that 
\begin_inset Formula $\mathtt{fst}\,M\equiv7$
\end_inset

 if 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
M\equiv\left\langle 7,\lambda y.\mathtt{loopForever}\right\rangle 
\]

\end_inset


\end_layout

\begin_layout Standard
The hope would be that the type is sufficient to communicate intent, in
 the same way unproductive non-termination is typeable in mainstream programming
 languages but still considered a bug.
\end_layout

\begin_layout Subsection
Prior work for the Base Language
\end_layout

\begin_layout Standard
While many of these features have been explored in theory and implemented
 in practice, I am unaware of any development with exactly this formulation.
\end_layout

\begin_layout Standard
Unsound logical systems that are acceptable programming languages go back
 to at least to Church's lambda calculus which was originally intended to
 be a logical foundation for mathematics.
 Martin Lof proposed a system with Type-in-type that was shown logically
 unsound by Girard (as described in the introduction in 
\begin_inset CommandInset citation
LatexCommand cite
key "Martin-Lof-1972"
literal "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
The first proof of type soundness for general recursive functions that I
 am aware of came form the Trellys Project 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

, it contains many similar features, but the base language uses a simpler
 notion of equality and dependent data resulting in an arguably simpler
 proof of type soundness.
 Further work in the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 used modalities to separate the terminating and non terminating fragments
 of the language, thought the annotations burden seems too high in practice.
 In general the base language has been deeply informed by the Trellys Project
\begin_inset CommandInset citation
LatexCommand cite
key "kimmell2012equational"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "casinghino2014combining,casinghino2014combiningthesis"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015programming"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 and the Zombie Language
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/sweirich/trellys
\end_layout

\end_inset

 it produced.
\end_layout

\begin_layout Standard
Several implementations support this combination of features without proofs
 of type soundness.
 Cayenne 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/289423.289451"
literal "false"

\end_inset

 was an early Haskell like language combined dependent types with and non-termin
ation.
 Agda supports general recursion and Type-in-type with compiler flags, and
 can simulate some non-positive data types using coinduction.
 Idris supports similar 
\begin_inset Quotes eld
\end_inset

unsafe
\begin_inset Quotes erd
\end_inset

 features.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "jia2010dependent"
literal "false"

\end_inset

 introduces a similar 
\begin_inset Quotes eld
\end_inset

partial correctness
\begin_inset Quotes erd
\end_inset

 criterion.
\end_layout

\begin_layout Section
A Language with Dynamic Type Equality
\end_layout

\begin_layout Standard
A key issue with full-spectrum dependent type theories is the characterization
 of definitional equality.
 Since computation can appear at the type level, and types must be checked
 for equality, dependent type theories must define what computational equalities
 they intend to support.
 For instance, the base language follows the common choice of 
\begin_inset Formula $\alpha\beta$
\end_inset

 equivalence of terms.
 However this causes many programs to not type-check:
\end_layout

\begin_layout Standard
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 Since 
\begin_inset Formula $1+x$
\end_inset

 does not have the same definition as 
\begin_inset Formula $x+1$
\end_inset

.
\end_layout

\begin_layout Standard
This is a widely recognized issue with Dependent Type Theories.
 However most attempts to improve the equality relation intend to preserve
 decidable type checking and/or logical soundness, so equality will never
 be complete
\begin_inset Foot
status open

\begin_layout Plain Layout
I am also unaware of any suitable notion of complete extensional equality
 for dependent type theory though it is considered in 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2015dependently"
literal "false"

\end_inset

 .
\end_layout

\end_inset

.
 Since dependently typed languages with the practical features outlined
 in base language are already incompatible with logical soundness and decidable
 type checking, these concerns no longer apply.
\end_layout

\begin_layout Standard
The base language can be extended to a cast language that supports the expectati
on of the original typing.
 Many programs that do not type in the base language can be elaborated into
 the cast language.
 The cast language has a weaker notion of type soundness such that 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $e'\downarrow v'$
\end_inset

 and 
\begin_inset Formula $\vdash_{c}v':M'$
\end_inset

 
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $e'\uparrow$
\end_inset

 
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $e'\downarrow blame$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
Type soundness is preserved, or inequality can be proven at a specific source
 location.
 In the example above 
\begin_inset Formula $\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,\left(x+1\right)\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}$
\end_inset

 will not emit any errors at compile time or runtime (though a static warning
 may be given).
 
\end_layout

\begin_layout Standard
If the example is changed to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.\mathtt{head}\,x\,\left(\mathtt{rep}\,x\right)\,:\,\mathbb{N}\rightarrow\mathbb{B}
\]

\end_inset


\end_layout

\begin_layout Standard
and the function is called at runtime, the blame tracking system will blame
 the exact static location that uses unequal types with a direct proof of
 inequality, allowing an error like 
\begin_inset Quotes eld
\end_inset

failed at application 
\begin_inset Formula $\left(\mathtt{head}\,x:\mathtt{Vec}\,\underline{\left(1+x\right)}\,\mathbb{B}\rightarrow...\right)\left(rep\,x:\mathtt{Vec}\,\underline{x}\,\mathbb{B}\right)$
\end_inset

 since when 
\begin_inset Formula $x=3$
\end_inset

, 
\begin_inset Formula $1+x=4\neq3=x$
\end_inset


\begin_inset Quotes erd
\end_inset

, regardless of where function was called in the program and where the discrepan
cy was discovered.
 This improves on the naive solution of completely ignoring type annotations
 for execution, since without type soundness, the returned error may appear
 unrelated to the problematic type assumption (
\begin_inset Quotes eld
\end_inset

3 applied to 7 but 7 is not a function
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard
Just as standard type theories allow many possible characterizations of
 equality that support logical soundness, there are many choices of runtime
 checking that support this notion of type soundness.
 The minimal choice is likely too permissive in practice: in the example
 above, it would only flag an error when the function is applied to 0.
 Alternatively, I conjecture that runtime-checking that matches the partial
 correctness criteria above would be reasonably intuitive.
 Extending checks into non dependent function types also seems reasonable,
 and would allow simple types to be completely checked.
\end_layout

\begin_layout Standard
Taking inspiration from the 
\begin_inset Quotes eld
\end_inset

gradual guarantee
\begin_inset Quotes erd
\end_inset

 of gradual typing, there are several basic properties in addition to type
 soundness that this cast language hopes to fulfill:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash e:M$
\end_inset

, 
\begin_inset Formula $elab\left(M,*\right)=M'$
\end_inset

, and 
\begin_inset Formula $elab\left(e,M'\right)=e'$
\end_inset

 then 
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':M'$
\end_inset

 and 
\begin_inset Formula $e'\downarrow blame$
\end_inset

 then there is no 
\begin_inset Formula $\vdash e:M$
\end_inset

 such that 
\begin_inset Formula $elab\left(M,*\right)=M'$
\end_inset

, 
\begin_inset Formula $elab\left(e,M'\right)=e'$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vdash_{c}e':*$
\end_inset

 and 
\begin_inset Formula $elab\left(e,*\right)=e'$
\end_inset

 then
\end_layout

\begin_deeper
\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow*$
\end_inset

 then 
\begin_inset Formula $e\downarrow*$
\end_inset


\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow(x:M')\rightarrow N'$
\end_inset

 then 
\begin_inset Formula $e\downarrow(x:M)\rightarrow N$
\end_inset

 
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $e'\downarrow TCon\triangle'$
\end_inset

 then 
\begin_inset Formula $e\downarrow TCon\triangle$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
The first condition states that every typed term in the base language can
 be embedded in the cast language.
 The second condition shows that errors are not spurious.
 The third condition shows that except for error, observations are consistent
 (with large eliminations, term constructors can also be observed).
\end_layout

\begin_layout Subsection
Status
\end_layout

\begin_layout Standard
I am rewriting a prototype that has support for all the features of the
 base language.
 The fragment for dependent function types and type universes satisfies
 all the conditions above.
 I believe that all conditions can be made to hold with data types as well.
\end_layout

\begin_layout Subsection
Prior work
\end_layout

\begin_layout Standard
It is unsurprising that dynamic equality is shares many of the same concerns
 as the large amount of work for contracts, hybrid types, gradual types,
 and blame.
 In fact, this work could be seen as gradualizing the Reflection Rule in
 Extensional Type Theory.
\end_layout

\begin_layout Standard
Blame has been strongly advocated for in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-00590-9_1,wadler:LIPIcs:2015:5033"
literal "false"

\end_inset

.
 Blame tracking can help establish the reasonableness of monitoring systems
 by linking a dynamic failure directly to the broken static invariant.
 blame is also a key ingredient of good error messages.
 However, as many authors have noticed, proving blame correctness is tedious
 and error prone, it is often only conjectured.
\end_layout

\begin_layout Standard
The basic correctness conditions are inspired by the Gradual Guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031"
literal "false"

\end_inset

.
 The implementation also takes inspiration from 
\begin_inset Quotes eld
\end_inset

Abstracting gradual typing
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2837614.2837670"
literal "false"

\end_inset

, where static evidence annotations become runtime checks.
 Unlike some impressive attempts to gradualize the polymorphic lambda calculus
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3110283"
literal "false"

\end_inset

, dynamic equality does not attempt to preserve any parametric properties
 of the base language.
 It is unclear how useful such a restriction to parametric properties would
 be in practice.
\end_layout

\begin_layout Standard
A direct attempt has been made to gradualize a full spectrum dependently
 typed language to an untyped lambda calculus using the AGT philosophy in
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3341692"
literal "false"

\end_inset

.
 However that system retains the intentional style of equality and user
 defined data types are not supported.
 The paper is largely concerned with establishing decidable type checking
 via an approximate term normalization.
\end_layout

\begin_layout Standard
A refinement type system with higher order features is gradualized in 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 though it does not appear powerful enough to be characterized a a full-spectrum
 dependent type theory.
 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

 builds on earlier refinement type system work, which described itself as
 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

.
 A notable example is 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/1-4020-8141-3_34"
literal "false"

\end_inset

 which describes a refinement system that limit's predicates to base types.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
Dynamic equality appears to be a prerequisite to other interesting possibilities
\end_layout

\begin_layout Subsection
Prototyping proofs and programs
\end_layout

\begin_layout Standard
Just as 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equalities are missing from the definitional relation, 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 proofs and programs are not always conveniently available to the programmer.
 For instance, in Agda it is possible to write a sorting function quickly
 using simple types.
 With effort is it possible to prove that sorting procedure correct by rewriting
 it with the necessarily invariants.
 However very little is offered in between.
 The problem is magnified if module boundaries hide the implementation details
 of a function, since the details are exactly what is needed to make a proof!
 This is especially important for larger scale software where a library
 may require proof terms that while 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 are not constructable from the exports of other libraries.
\end_layout

\begin_layout Standard
The solution proposed here is some additional syntax that will search for
 a term of the type when resolved at runtime.
 Given the sorting function 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{sort}:\mathtt{List}\,\mathbb{N}\rightarrow\mathtt{List}\,\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
and given the first order predicate that 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{IsSorted}:\mathtt{List}\,\mathbb{N}\rightarrow*
\]

\end_inset


\end_layout

\begin_layout Standard
then it is possible to assert that 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 behaves as expected with
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.?:\left(x:\mathtt{List}\,\mathbb{N}\right)\rightarrow\mathtt{IsSorted}\left(\mathtt{sort}x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
this term will act like any other function at runtime, given a list input
 it will verify that the 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 function correctly handles that input, give an error, or non-terminate.
\end_layout

\begin_layout Standard
Additionally this would allow simple prototyping form first order specification.
 For instance,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
data\,\mathtt{Mult} & :\mathbb{N}\rightarrow\mathbb{N}\rightarrow\mathbb{N}\rightarrow*\,where\\
\mathtt{base} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Mult}0\,x\,0\\
\mathtt{suc} & :\left(x\,y\,z:\mathbb{N}\right)\rightarrow\mathtt{Mult}\,x\,y\,z\rightarrow\mathtt{Mult}\,\left(1+x\right)\,y\,(y+z)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
can be used to prototype
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{div}=\lambda x.\lambda y.\mathtt{fst}\left(?:\sum z:\mathbb{N}.\mathtt{Mult}x\,y\,z\right)
\]

\end_inset


\end_layout

\begin_layout Standard
The term search can be surprisingly subtle, for instance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
?:\sum f:\mathbb{N}\rightarrow\mathbb{N}.\mathtt{Id}\left(f,\lambda x.x+1\right)\&\mathtt{Id}\left(f,\lambda x.1+x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
depends on the definitional properties of functions.
 To avoid this subtly I plan to only support term search over first order
 data.
\end_layout

\begin_layout Standard
Though the proof search is currently primitive, better search methods could
 be incorporated in future work.
\end_layout

\begin_layout Subsubsection
Prior work
\end_layout

\begin_layout Standard
Proof search is often used for static term generation in dependently typed
 languages (for instance Coq tactics).
 A first order theorem prover is attached to Agda in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Twelf made use of runtime proof search but the underling theory cannot be
 considered full-spectrum.
\end_layout

\begin_layout Subsection
Testing dependent programs
\end_layout

\begin_layout Standard
Both dynamic equalities and dynamic proof search vastly weaken the guarantees
 of normal dependent type systems.
 Programmers still would like a evidence of correctness, even while they
 intend to provide full proofs of properties in the future.
 However, there are few options available in full-spectrum dependently typed
 languages aside from costly and sometimes unconstructable proofs.
\end_layout

\begin_layout Standard
The mainstream software industry has similar needs for evidence of correctness,
 and has made use of testing done in a separate execution phase.
 Given the rich specifications that dependent types provide it is possible
 to improve on the hand crafted tests used by most of the industry.
 Instead we can use a type directed symbolic execution, to run questionable
 equalities over concrete values and engage and precompute the searched
 proof terms.
 Precomputed proof terms can be cached, so that exploration is not too inefficie
nt in the common case of repeating tests at regular intervals of code that
 is mostly the same.
 Precomputed terms can be made available at runtime, covering for the inefficien
t search procedure.
 
\end_layout

\begin_layout Standard
Interestingly dynamic equality is necessary for testing like this, since
 otherwise, definitional properties of functions would need to be accounted
 for.
 Using dynamic equality it is possible only consider the extensional behavior
 of functions.
\end_layout

\begin_layout Standard
Finally future work can add more advanced methods of testing and proof generatio
n.
 This architecture should make it easier to add more advanced exploration
 and search without changing the underlining definitional behavior.
\end_layout

\begin_layout Subsubsection
Prior work 
\end_layout

\begin_layout Subsubsection
Symbolic Execution
\end_layout

\begin_layout Standard
Most research for Symbolic Execution targets popular imparative languages
 (like C) and uses SMT solvers to efficiently explore conditional branches
 that depend on base types.
 Most work does not support higher order functions or makes simplifying
 assumptions about the type system.
 There are however some relevant papers:
\end_layout

\begin_layout Itemize
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

 presents a symbolic execution engine supporting Haskell's lazy execution
 and type system.
 Higher order functions are not handled
\end_layout

\begin_layout Itemize
The draft work
\begin_inset CommandInset citation
LatexCommand cite
key "2006.11639"
literal "false"

\end_inset

, handles higher order functions as and inputs provides a proof of completeness
\end_layout

\begin_layout Itemize
Symbolic execution for higher order functions for a limited untyped variant
 of PCF is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "nguyen2017higher"
literal "false"

\end_inset


\end_layout

\begin_layout Subsubsection
Testing dependent types
\end_layout

\begin_layout Standard
There has been a long recognized need for testing in addition to proving
 in dependent type systems
\end_layout

\begin_layout Itemize
In 
\begin_inset CommandInset citation
LatexCommand cite
key "dybjer2003combining"
literal "false"

\end_inset

 a QuickCheck style framework was added to an earlier version of Agda
\end_layout

\begin_layout Itemize
QuickChick
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/QuickChick/QuickChick
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "denes2014quickchick"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lampropoulos2017generating,lampropoulos2017beginner,lampropoulos2018random"
literal "false"

\end_inset

 is a research project to add testing to Coq.
 However testing requires building types classes that establish the properties
 needed by the testing framework such as decidable equality.
 This is presumably out of reach of novice Coq users.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "C:/icfp/dtest/extended-abstract/dtest"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
